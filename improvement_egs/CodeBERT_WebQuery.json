[
    [
        "how to make word into letter by letter in python",
        [
            "def downcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to lower case.\"\"\"     return [ tt.lower() for tt in map(_ustr,t) ]",
            "def upcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to upper case.\"\"\"     return [ tt.upper() for tt in map(_ustr,t) ]",
            "def casefold_with_i_dots(text):     \"\"\"     Convert capital I's and capital dotted \u0130's to lowercase in the way     that's appropriate for Turkish and related languages, then case-fold     the rest of the letters.     \"\"\"     text = unicodedata.normalize('NFC', text).replace('\u0130', 'i').replace('I', '\u0131')     return text.casefold()",
            "def normalize(pw):     \"\"\" Lower case, and change the symbols to closest characters\"\"\"     pw_lower = pw.lower()     return ''.join(helper.L33T.get(c, c) for c in pw_lower)",
            "def slugify(value):     \"\"\"Simple Slugify.\"\"\"     s1 = first_cap_re.sub(r'\\1_\\2', value)     s2 = all_cap_re.sub(r'\\1_\\2', s1)     return s2.lower().replace(' _', '_').replace(' ', '_')"
        ],
        [
            "def upcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to upper case.\"\"\"     return [ tt.upper() for tt in map(_ustr,t) ]",
            "def downcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to lower case.\"\"\"     return [ tt.lower() for tt in map(_ustr,t) ]",
            "def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)",
            "def unduplicate_field_names(field_names):     \"\"\"Append a number to duplicate field names to make them unique. \"\"\"     res = []     for k in field_names:         if k in res:             i = 1             while k + '_' + str(i) in res:                 i += 1             k += '_' + str(i)         res.append(k)     return res",
            "def return_letters_from_string(text):     \"\"\"Get letters from string only.\"\"\"     out = \"\"     for letter in text:         if letter.isalpha():             out += letter     return out"
        ],
        [
            "def casefold_with_i_dots(text):     \"\"\"     Convert capital I's and capital dotted \u0130's to lowercase in the way     that's appropriate for Turkish and related languages, then case-fold     the rest of the letters.     \"\"\"     text = unicodedata.normalize('NFC', text).replace('\u0130', 'i').replace('I', '\u0131')     return text.casefold()",
            "def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])"
        ]
    ],
    [
        "check list in a string python",
        [
            "def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found",
            "def any_contains_any(strings, candidates):     \"\"\"Whether any of the strings contains any of the candidates.\"\"\"     for string in strings:         for c in candidates:             if c in string:                 return True",
            "def __contains__(self, char):  # noqa: D105         \"\"\"Implement the `in` keyword, searches the sequence.         \"\"\"         return len(char) <= len(self) and char in str(self.seq) * 2",
            "def chk_enum_arg(s):     \"\"\"Checks if the string `s` is a valid enum string.      Return True or False.\"\"\"      if len(s) == 0 or s[0].isspace() or s[-1].isspace():         return False     else:         return True",
            "def valid_substitution(strlen, index):     \"\"\"     skip performing substitutions that are outside the bounds of the string     \"\"\"     values = index[0]     return all([strlen > i for i in values])"
        ],
        [
            "def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found",
            "def any_contains_any(strings, candidates):     \"\"\"Whether any of the strings contains any of the candidates.\"\"\"     for string in strings:         for c in candidates:             if c in string:                 return True",
            "def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]",
            "def valid_substitution(strlen, index):     \"\"\"     skip performing substitutions that are outside the bounds of the string     \"\"\"     values = index[0]     return all([strlen > i for i in values])",
            "def valid (names):     \"\"\" Returns true iff all elements of names are valid features.     \"\"\"     if isinstance(names, str):         names = [names]         assert is_iterable_typed(names, basestring)      return all(name in __all_features for name in names)"
        ],
        [
            "def chk_enum_arg(s):     \"\"\"Checks if the string `s` is a valid enum string.      Return True or False.\"\"\"      if len(s) == 0 or s[0].isspace() or s[-1].isspace():         return False     else:         return True",
            "def __is__(cls, s):         \"\"\"Test if string matches this argument's format.\"\"\"         return s.startswith(cls.delims()[0]) and s.endswith(cls.delims()[1])"
        ]
    ],
    [
        "check if all elements in a list are in a list of list python",
        [
            "def equal(list1, list2):     \"\"\" takes flags returns indexes of True values \"\"\"     return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]",
            "def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)",
            "def obj_in_list_always(target_list, obj):     \"\"\"     >>> l = [1,1,1]     >>> obj_in_list_always(l, 1)     True     >>> l.append(2)     >>> obj_in_list_always(l, 1)     False     \"\"\"     for item in set(target_list):         if item is not obj:             return False     return True",
            "def isin(value, values):     \"\"\" Check that value is in values \"\"\"     for i, v in enumerate(value):         if v not in np.array(values)[:, i]:             return False     return True",
            "def is_list_of_states(self, arg):         \"\"\"         A list of states example -         [('x1', 'easy'), ('x2', 'hard')]          Returns         -------         True, if arg is a list of states else False.          \"\"\"         return isinstance(arg, list) and all(isinstance(i, tuple) for i in arg)"
        ],
        [
            "def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)",
            "def equal(list1, list2):     \"\"\" takes flags returns indexes of True values \"\"\"     return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]",
            "def obj_in_list_always(target_list, obj):     \"\"\"     >>> l = [1,1,1]     >>> obj_in_list_always(l, 1)     True     >>> l.append(2)     >>> obj_in_list_always(l, 1)     False     \"\"\"     for item in set(target_list):         if item is not obj:             return False     return True",
            "def _uniquify(_list):     \"\"\"Remove duplicates in a list.\"\"\"     seen = set()     result = []     for x in _list:         if x not in seen:             result.append(x)             seen.add(x)     return result",
            "def dedupe_list(l):     \"\"\"Remove duplicates from a list preserving the order.      We might be tempted to use the list(set(l)) idiom, but it doesn't preserve     the order, which hinders testability and does not work for lists with     unhashable elements.     \"\"\"     result = []      for el in l:         if el not in result:             result.append(el)      return result"
        ],
        [
            "def valid (names):     \"\"\" Returns true iff all elements of names are valid features.     \"\"\"     if isinstance(names, str):         names = [names]         assert is_iterable_typed(names, basestring)      return all(name in __all_features for name in names)",
            "def is_list_of_states(self, arg):         \"\"\"         A list of states example -         [('x1', 'easy'), ('x2', 'hard')]          Returns         -------         True, if arg is a list of states else False.          \"\"\"         return isinstance(arg, list) and all(isinstance(i, tuple) for i in arg)"
        ]
    ],
    [
        "python check if a number is n",
        [
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False",
            "def isreal(obj):     \"\"\"     Test if the argument is a real number (float or integer).      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return (         (obj is not None)         and (not isinstance(obj, bool))         and isinstance(obj, (int, float))     )",
            "def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False",
            "def IntGreaterThanZero(n):     \"\"\"If *n* is an integer > 0, returns it, otherwise an error.\"\"\"     try:         n = int(n)     except:         raise ValueError(\"%s is not an integer\" % n)     if n <= 0:         raise ValueError(\"%d is not > 0\" % n)     else:         return n"
        ],
        [
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def is_valid(number):     \"\"\"determines whether the card number is valid.\"\"\"     n = str(number)     if not n.isdigit():         return False     return int(n[-1]) == get_check_digit(n[:-1])",
            "def isreal(obj):     \"\"\"     Test if the argument is a real number (float or integer).      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return (         (obj is not None)         and (not isinstance(obj, bool))         and isinstance(obj, (int, float))     )",
            "def is_number(obj):     \"\"\"     Helper function to determine numbers     across Python 2.x and 3.x     \"\"\"     try:         from numbers import Number     except ImportError:         from operator import isNumberType         return isNumberType(obj)     else:         return isinstance(obj, Number)",
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False"
        ],
        [
            "def _nth_str(n):     \"\"\"Return posessive form of numeral `n`: 1st, 2nd, 3rd, etc.\"\"\"     if n % 10 == 1 and n % 100 != 11:         return \"%dst\" % n     if n % 10 == 2 and n % 100 != 12:         return \"%dnd\" % n     if n % 10 == 3 and n % 100 != 13:         return \"%drd\" % n     return \"%dth\" % n",
            "def IntGreaterThanZero(n):     \"\"\"If *n* is an integer > 0, returns it, otherwise an error.\"\"\"     try:         n = int(n)     except:         raise ValueError(\"%s is not an integer\" % n)     if n <= 0:         raise ValueError(\"%d is not > 0\" % n)     else:         return n"
        ]
    ],
    [
        "format array python string",
        [
            "def list_to_str(list, separator=','):     \"\"\"     >>> list = [0, 0, 7]     >>> list_to_str(list)     '0,0,7'     \"\"\"     list = [str(x) for x in list]     return separator.join(list)",
            "def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)",
            "def safe_format(s, **kwargs):   \"\"\"   :type s str   \"\"\"   return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))",
            "def _tuple_repr(data):     \"\"\"Return a repr() for a list/tuple\"\"\"     if len(data) == 1:         return \"(%s,)\" % rpr(data[0])     else:         return \"(%s)\" % \", \".join([rpr(x) for x in data])",
            "def __repr__(self):         \"\"\"         Basic string representation of the order.         \"\"\"         list_repr = \"<MarketOrderList: \\n\"          for order_list in [olist.orders for olist in self._orders.values()]:             for order in order_list:                 list_repr += repr(order)          return list_repr"
        ],
        [
            "def format(x, format):     \"\"\"Uses http://www.cplusplus.com/reference/string/to_string/ for formatting\"\"\"     # don't change the dtype, otherwise for each block the dtype may be different (string length)     sl = vaex.strings.format(x, format)     return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)",
            "def __str__(self): \t\t\"\"\" Convert to string  \t\t:return: str \t\t\"\"\" \t\taddress = [\"{:02x}\".format(int(x)) for x in self.__address] \t\treturn ':'.join(address)",
            "def _tuple_repr(data):     \"\"\"Return a repr() for a list/tuple\"\"\"     if len(data) == 1:         return \"(%s,)\" % rpr(data[0])     else:         return \"(%s)\" % \", \".join([rpr(x) for x in data])",
            "def pretty_dict_str(d, indent=2):     \"\"\"shows JSON indented representation of d\"\"\"     b = StringIO()     write_pretty_dict_str(b, d, indent=indent)     return b.getvalue()",
            "def string_repr(s):     \"\"\"Return a string as hex dump.\"\"\"     if compat.is_bytes(s):         res = \"{!r}: \".format(s)         for b in s:             if type(b) is str:  # Py2                 b = ord(b)             res += \"%02x \" % b         return res     return \"{}\".format(s)"
        ],
        [
            "def string_format_func(s): \t\"\"\" \tFunction used internally to format string data for output to XML. \tEscapes back-slashes and quotes, and wraps the resulting string in \tquotes. \t\"\"\" \treturn u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")",
            "def safe_format(s, **kwargs):   \"\"\"   :type s str   \"\"\"   return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))"
        ]
    ],
    [
        "enforcing input length in python",
        [
            "def length(length):     \"\"\"Checks value for minimum length using len().\"\"\"     def min_len(value):         if not len(value) >= length:             raise ValueError(                 \"Minimum length is {0} but value is {1}\".format(length, len(value))             )         return True      return min_len",
            "def valid_substitution(strlen, index):     \"\"\"     skip performing substitutions that are outside the bounds of the string     \"\"\"     values = index[0]     return all([strlen > i for i in values])",
            "def onscreen_len(s):     \"\"\"     Calculate the length of a unicode string on screen,     accounting for double-width characters      \"\"\"      if sys.version_info < (3, 0) and isinstance(s, str):         return len(s)      length = 0     for ch in s:         length += 2 if unicodedata.east_asian_width(ch) == 'W' else 1      return length",
            "def validate_non_negative_integer(option, value):     \"\"\"Validate that 'value' is a positive integer or 0.     \"\"\"     val = validate_integer(option, value)     if val < 0:         raise ValueError(\"The value of %s must be \"                          \"a non negative integer\" % (option,))     return val",
            "def validate_positive_integer(option, value):     \"\"\"Validate that 'value' is a positive integer, which does not include 0.     \"\"\"     val = validate_integer(option, value)     if val <= 0:         raise ValueError(\"The value of %s must be \"                          \"a positive integer\" % (option,))     return val"
        ],
        [
            "def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val",
            "def random_id(length):     \"\"\"Generates a random ID of given length\"\"\"      def char():         \"\"\"Generate single random char\"\"\"          return random.choice(string.ascii_letters + string.digits)      return \"\".join(char() for _ in range(length))",
            "def array_dim(arr):     \"\"\"Return the size of a multidimansional array.     \"\"\"     dim = []     while True:         try:             dim.append(len(arr))             arr = arr[0]         except TypeError:             return dim",
            "def concat_padded(base, *args):     \"\"\"     Concatenate string and zero-padded 4 digit number     \"\"\"     ret = base     for n in args:         if is_string(n):             ret = \"%s_%s\" % (ret, n)         else:             ret = \"%s_%04i\"  % (ret, n + 1)     return ret",
            "def u16le_list_to_byte_list(data):     \"\"\"! @brief Convert a halfword array into a byte array\"\"\"     byteData = []     for h in data:         byteData.extend([h & 0xff, (h >> 8) & 0xff])     return byteData"
        ],
        [
            "def length(length):     \"\"\"Checks value for minimum length using len().\"\"\"     def min_len(value):         if not len(value) >= length:             raise ValueError(                 \"Minimum length is {0} but value is {1}\".format(length, len(value))             )         return True      return min_len",
            "def __len__(self):         \"\"\" This will equal 124 for the V1 database. \"\"\"         length = 0         for typ, siz, _ in self.format:             length += siz         return length"
        ]
    ],
    [
        "how to remove integers from string python",
        [
            "def _naturalize_numbers(self, string):         \"\"\"         Makes any integers into very zero-padded numbers.         e.g. '1' becomes '00000001'.         \"\"\"          def naturalize_int_match(match):             return '%08d' % (int(match.group(0)),)          string = re.sub(r'\\d+', naturalize_int_match, string)          return string",
            "def try_cast_int(s):     \"\"\"(str) -> int     All the digits in a given string are concatenated and converted into a single number.     \"\"\"     try:         temp = re.findall('\\d', str(s))         temp = ''.join(temp)         return int(temp)     except:         return s",
            "def str2int(string_with_int):     \"\"\" Collect digits from a string \"\"\"     return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)",
            "def robust_int(v):     \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"      if isinstance(v, int):         return v      if isinstance(v, float):         return int(v)      v = str(v).replace(',', '')      if not v:         return None      return int(v)",
            "def get_number(s, cast=int):     \"\"\"     Try to get a number out of a string, and cast it.     \"\"\"     import string     d = \"\".join(x for x in str(s) if x in string.digits)     return cast(d)"
        ],
        [
            "def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s",
            "def strip_codes(s: Any) -> str:     \"\"\" Strip all color codes from a string.         Returns empty string for \"falsey\" inputs.     \"\"\"     return codepat.sub('', str(s) if (s or (s == 0)) else '')",
            "def _naturalize_numbers(self, string):         \"\"\"         Makes any integers into very zero-padded numbers.         e.g. '1' becomes '00000001'.         \"\"\"          def naturalize_int_match(match):             return '%08d' % (int(match.group(0)),)          string = re.sub(r'\\d+', naturalize_int_match, string)          return string",
            "def dashrepl(value):     \"\"\"     Replace any non-word characters with a dash.     \"\"\"     patt = re.compile(r'\\W', re.UNICODE)     return re.sub(patt, '-', value)",
            "def _check_and_convert_bools(self):         \"\"\"Replace boolean variables by the characters 'F'/'T'         \"\"\"         replacements = {             True: 'T',             False: 'F',         }          for key in self.bools:             if isinstance(self[key], bool):                 self[key] = replacements[self[key]]"
        ],
        [
            "def str2int(string_with_int):     \"\"\" Collect digits from a string \"\"\"     return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)",
            "def get_numbers(s):     \"\"\"Extracts all integers from a string an return them in a list\"\"\"      result = map(int, re.findall(r'[0-9]+', unicode(s)))     return result + [1] * (2 - len(result))"
        ]
    ],
    [
        "get double valuye datetime python",
        [
            "def date_to_number(self, date):         \"\"\"         Converts a date or datetime instance to a corresponding float value.         \"\"\"         if isinstance(date, datetime.datetime):             delta = date - self._null_date         elif isinstance(date, datetime.date):             delta = date - self._null_date.date()         else:             raise TypeError(date)         return delta.days + delta.seconds / (24.0 * 60 * 60)",
            "def timestamp_to_datetime(timestamp):     \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"     from datetime import datetime, timedelta     obj = datetime.fromtimestamp(timestamp[0])     return obj + timedelta(microseconds=int(timestamp[1]))",
            "def timestamp_from_dt(dt, epoch=datetime(1970, 1, 1)):     \"\"\"     Convert a datetime to a timestamp.     https://stackoverflow.com/a/8778548/141395     \"\"\"     delta = dt - epoch     # return delta.total_seconds()     return delta.seconds + delta.days * 86400",
            "def date_to_timestamp(date):     \"\"\"         date to unix timestamp in milliseconds     \"\"\"     date_tuple = date.timetuple()     timestamp = calendar.timegm(date_tuple) * 1000     return timestamp",
            "def convert_timestamp(timestamp):     \"\"\"     Converts bokehJS timestamp to datetime64.     \"\"\"     datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)     return np.datetime64(datetime.replace(tzinfo=None))"
        ],
        [
            "def biweekly(date=datetime.date.today()):     \"\"\"     Every two weeks.     \"\"\"     return datetime.date(date.year, date.month, 1 if date.day < 15 else 15)",
            "def created_today(self):         \"\"\"Return True if created today.\"\"\"         if self.datetime.date() == datetime.today().date():             return True         return False",
            "def is_third_friday(day=None):     \"\"\" check if day is month's 3rd friday \"\"\"     day = day if day is not None else datetime.datetime.now()     defacto_friday = (day.weekday() == 4) or (         day.weekday() == 3 and day.hour() >= 17)     return defacto_friday and 14 < day.day < 22",
            "def last_midnight():     \"\"\"     return a datetime of last mid-night     \"\"\"     now = datetime.now()     return datetime(now.year, now.month, now.day)",
            "def now_time(str=False):     \"\"\"Get the current time.\"\"\"     if str:         return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")     return datetime.datetime.now()"
        ],
        [
            "def date_to_timestamp(date):     \"\"\"         date to unix timestamp in milliseconds     \"\"\"     date_tuple = date.timetuple()     timestamp = calendar.timegm(date_tuple) * 1000     return timestamp",
            "def timestamp_to_datetime(timestamp):     \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"     from datetime import datetime, timedelta     obj = datetime.fromtimestamp(timestamp[0])     return obj + timedelta(microseconds=int(timestamp[1]))"
        ]
    ],
    [
        "python script to shutdown computer os independent",
        [
            "def _shutdown(self):     \"\"\"Terminate the sub-process.\"\"\"     if self._proc:       ret = _shutdown_proc(self._proc, 3)       logging.info(\"Shutdown with return code: %s\", ret)       self._proc = None",
            "def _quit(self, *args):         \"\"\" quit crash \"\"\"         self.logger.warn('Bye!')         sys.exit(self.exit())",
            "def disown(cmd):     \"\"\"Call a system command in the background,        disown it and hide it's output.\"\"\"     subprocess.Popen(cmd,                      stdout=subprocess.DEVNULL,                      stderr=subprocess.DEVNULL)",
            "def do_exit(self, arg):         \"\"\"Exit the shell session.\"\"\"          if self.current:             self.current.close()         self.resource_manager.close()         del self.resource_manager         return True",
            "def stop_process(self):         \"\"\"         Stops the child process.         \"\"\"         self._process.terminate()         if not self._process.waitForFinished(100):             self._process.kill()"
        ],
        [
            "def disown(cmd):     \"\"\"Call a system command in the background,        disown it and hide it's output.\"\"\"     subprocess.Popen(cmd,                      stdout=subprocess.DEVNULL,                      stderr=subprocess.DEVNULL)",
            "def __init__(self, pidfile, daemonize=True, root=False, root_chk_argv=True, stdin=\"/dev/null\", stdout=\"/dev/null\", stderr=\"/dev/null\"): \t\t\"\"\" \t\tMake our daemon instance. \t\tpidfile: the file we're going to store the process id in. ex: /tmp/matt-daemon.pid \t\troot:    does this script require root? True if it does, False if it doesn't. Will be enforced. \t\troot_chk_argv:  does the script require '--requires-root' in sys.argv to run as root? (usage is good) \t\tstdin:   where the script gets stdin from. \"/dev/null\", \"/dev/stdin\", etc. \t\tstdout:  where the script writes stdout. \"/dev/null\", \"/dev/stdout\", etc. \t\tstderr:  where the script writes stderr. \"/dev/null\", \"/dev/stderr\", etc. \t\t\"\"\" \t\t# Enforce root usage or non-usage. \t\tRootCheck.check(root, check_argv=root_chk_argv) \t\tself.pidfile = pidfile \t\tself.should_daemonize = daemonize \t\tself.stdin = stdin \t\tself.stdout = stdout \t\tself.stderr = stderr",
            "def exit(exit_code=0):   r\"\"\"A function to support exiting from exit hooks.    Could also be used to exit from the calling scripts in a thread safe manner.   \"\"\"   core.processExitHooks()    if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook     sys.stderr.flush()     sys.stdout.flush()     os._exit(exit_code) #pylint: disable=W0212    sys.exit(exit_code)",
            "def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)",
            "def _quit(self, *args):         \"\"\" quit crash \"\"\"         self.logger.warn('Bye!')         sys.exit(self.exit())"
        ],
        [
            "def shutdown(self):         \"\"\"         Shutdown the cluster.         \"\"\"         self.stop = True         if self.stats:             self.stats.shutDownStats()         self.join()",
            "def _shutdown(self):     \"\"\"Terminate the sub-process.\"\"\"     if self._proc:       ret = _shutdown_proc(self._proc, 3)       logging.info(\"Shutdown with return code: %s\", ret)       self._proc = None"
        ]
    ],
    [
        "how to fill the color in python",
        [
            "def write_color(string, name, style='normal', when='auto'):     \"\"\" Write the given colored string to standard out. \"\"\"     write(color(string, name, style, when))",
            "def add_bg(img, padding, color=COL_WHITE):     \"\"\"     Adds a padding to the given image as background of specified color      :param img: Input image.     :param padding: constant padding around the image.     :param color: background color that needs to filled for the newly padded region.     :return: New image with background.     \"\"\"     img = gray3(img)     h, w, d = img.shape     new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]     new_img = new_img.astype(np.uint8)     set_img_box(new_img, (padding, padding, w, h), img)     return new_img",
            "def draw(self, mode=\"triangles\"):         \"\"\" Draw collection \"\"\"          gl.glDepthMask(0)         Collection.draw(self, mode)         gl.glDepthMask(1)",
            "def ansi(color, text):     \"\"\"Wrap text in an ansi escape sequence\"\"\"     code = COLOR_CODES[color]     return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)",
            "def apply_mana_drain(self):         \"\"\"Clear current mana values.\"\"\"         self.r = self.g = self.b = self.y = 0"
        ],
        [
            "def add_bg(img, padding, color=COL_WHITE):     \"\"\"     Adds a padding to the given image as background of specified color      :param img: Input image.     :param padding: constant padding around the image.     :param color: background color that needs to filled for the newly padded region.     :return: New image with background.     \"\"\"     img = gray3(img)     h, w, d = img.shape     new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]     new_img = new_img.astype(np.uint8)     set_img_box(new_img, (padding, padding, w, h), img)     return new_img",
            "def lighting(im, b, c):     \"\"\" Adjust image balance and contrast \"\"\"     if b==0 and c==1: return im     mu = np.average(im)     return np.clip((im-mu)*c+mu+b,0.,1.).astype(np.float32)",
            "def apply_mana_drain(self):         \"\"\"Clear current mana values.\"\"\"         self.r = self.g = self.b = self.y = 0",
            "def draw(self, mode=\"triangles\"):         \"\"\" Draw collection \"\"\"          gl.glDepthMask(0)         Collection.draw(self, mode)         gl.glDepthMask(1)",
            "def gray2bgr(img):     \"\"\"Convert a grayscale image to BGR image.      Args:         img (ndarray or str): The input image.      Returns:         ndarray: The converted BGR image.     \"\"\"     img = img[..., None] if img.ndim == 2 else img     out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)     return out_img"
        ],
        [
            "def write_color(string, name, style='normal', when='auto'):     \"\"\" Write the given colored string to standard out. \"\"\"     write(color(string, name, style, when))",
            "def ansi(color, text):     \"\"\"Wrap text in an ansi escape sequence\"\"\"     code = COLOR_CODES[color]     return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)"
        ]
    ],
    [
        "how to access 3d array pythong",
        [
            "def add(self, x, axis):         \"\"\"Function to add 3D View with vector or 2D array (type = numpy.ndarray or 2D Field or 2D View) or 2D View with vector (type = numpy.ndarray)         :param x: array(1D, 2D) or field (2D) or View(2D)         :param axis: specifies axis, eg. axis = (1,2) plane lies in yz-plane, axis=0 vector along x axis         :return: dict with result of operation (same form as view.d)         \"\"\"         return self.__array_op(operator.add, x, axis)",
            "def recarray(self):         \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"         return numpy.rec.fromrecords(self.records, names=self.names)",
            "def append(self, value):         \"\"\"         \"\"\"         if isinstance(value, nparray.ndarray):             value = value.to_array()          new_value = np.append(self.get_value(), value)         self.set_value(new_value)",
            "def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S",
            "def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)"
        ],
        [
            "def recarray(self):         \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"         return numpy.rec.fromrecords(self.records, names=self.names)",
            "def constant(times: np.ndarray, amp: complex) -> np.ndarray:     \"\"\"Continuous constant pulse.      Args:         times: Times to output pulse for.         amp: Complex pulse amplitude.     \"\"\"     return np.full(len(times), amp, dtype=np.complex_)",
            "def torecarray(*args, **kwargs):     \"\"\"     Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.      \"\"\"      import numpy as np     return toarray(*args, **kwargs).view(np.recarray)",
            "def append(self, value):         \"\"\"         \"\"\"         if isinstance(value, nparray.ndarray):             value = value.to_array()          new_value = np.append(self.get_value(), value)         self.set_value(new_value)",
            "def is_empty(self):         \"\"\"Checks for an empty image.         \"\"\"         if(((self.channels == []) and (not self.shape == (0, 0))) or            ((not self.channels == []) and (self.shape == (0, 0)))):             raise RuntimeError(\"Channels-shape mismatch.\")         return self.channels == [] and self.shape == (0, 0)"
        ],
        [
            "def _transform_triple_numpy(x):     \"\"\"Transform triple index into a 1-D numpy array.\"\"\"     return np.array([x.head, x.relation, x.tail], dtype=np.int64)",
            "def S(self):         \"\"\":obj:`numpy.ndarray` : The 3x3 scaling matrix for this projection         \"\"\"         S = np.array([[self._plane_width / self._vol_width, 0, 0],                       [0, self._plane_height / self._vol_height, 0],                       [0, 0, self._depth_scale / self._vol_depth]])         return S"
        ]
    ],
    [
        "python how to only accept intigers as inputs",
        [
            "def validate_positive_integer(option, value):     \"\"\"Validate that 'value' is a positive integer, which does not include 0.     \"\"\"     val = validate_integer(option, value)     if val <= 0:         raise ValueError(\"The value of %s must be \"                          \"a positive integer\" % (option,))     return val",
            "def validate_non_negative_integer(option, value):     \"\"\"Validate that 'value' is a positive integer or 0.     \"\"\"     val = validate_integer(option, value)     if val < 0:         raise ValueError(\"The value of %s must be \"                          \"a non negative integer\" % (option,))     return val",
            "def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))",
            "def unit_net_value(self):         \"\"\"         [float] \u5b9e\u65f6\u51c0\u503c         \"\"\"         if self._units == 0:             return np.nan         return self.total_value / self._units",
            "def IntGreaterThanZero(n):     \"\"\"If *n* is an integer > 0, returns it, otherwise an error.\"\"\"     try:         n = int(n)     except:         raise ValueError(\"%s is not an integer\" % n)     if n <= 0:         raise ValueError(\"%d is not > 0\" % n)     else:         return n"
        ],
        [
            "def is_number(obj):     \"\"\"     Helper function to determine numbers     across Python 2.x and 3.x     \"\"\"     try:         from numbers import Number     except ImportError:         from operator import isNumberType         return isNumberType(obj)     else:         return isinstance(obj, Number)",
            "def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False",
            "def is_integer(obj):     \"\"\"Is this an integer.      :param object obj:     :return:     \"\"\"     if PYTHON3:         return isinstance(obj, int)     return isinstance(obj, (int, long))",
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False"
        ],
        [
            "def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))",
            "def robust_int(v):     \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"      if isinstance(v, int):         return v      if isinstance(v, float):         return int(v)      v = str(v).replace(',', '')      if not v:         return None      return int(v)"
        ]
    ],
    [
        "how to apply oop to fuction in python",
        [
            "def _apply_list(self, methods):     \"\"\"Return a single callable that applies a list of methods to a value.      If a method returns None, the last value is kept; if it returns     some other value, that replaces the last value.  Exceptions are     not caught.     \"\"\"     def call(value):       for method in methods:         newvalue = method(self, value)         if newvalue is not None:           value = newvalue       return value     return call",
            "def apply(f, obj, *args, **kwargs):     \"\"\"Apply a function in parallel to each element of the input\"\"\"     return vectorize(f)(obj, *args, **kwargs)",
            "def __init__(self,                  post_clean_up: Callable[[Sequence[ops.Operation]], ops.OP_TREE                                 ] = lambda op_list: op_list                  ) -> None:         \"\"\"         Args:             post_clean_up: This function is called on each set of optimized                 operations before they are put into the circuit to replace the                 old operations.         \"\"\"         self.post_clean_up = post_clean_up",
            "def one_over_x_like(x):     \"\"\"     returns -np.Inf if x<0, -np.log(x) otherwise.     \"\"\"     if np.any(x < 0):         return -np.Inf     else:         return -np.sum(np.log(x))",
            "def apply_operation(op_stack, out_stack):     \"\"\"     Apply operation to the first 2 items of the output queue      op_stack Deque (reference)     out_stack Deque (reference)     \"\"\"     out_stack.append(calc(out_stack.pop(), out_stack.pop(), op_stack.pop()))"
        ],
        [
            "def one_over_x_like(x):     \"\"\"     returns -np.Inf if x<0, -np.log(x) otherwise.     \"\"\"     if np.any(x < 0):         return -np.Inf     else:         return -np.sum(np.log(x))",
            "def spline_interpolate(x1, y1, x2):     \"\"\"     Given a function at a set of points (x1, y1), interpolate to     evaluate it at points x2.     \"\"\"     sp = Spline(x1, y1)     return sp(x2)",
            "def _gauss(mean: int, sigma: int) -> int:         \"\"\"         Creates a variation from a base value          Args:             mean: base value             sigma: gaussian sigma          Returns: random value          \"\"\"         return int(random.gauss(mean, sigma))",
            "def DynamicConvFilter(inputs, filters, out_channel,                       kernel_shape,                       stride=1,                       padding='SAME'):     \"\"\" see \"Dynamic Filter Networks\" (NIPS 2016)         by Bert De Brabandere*, Xu Jia*, Tinne Tuytelaars and Luc Van Gool      Remarks:         This is the convolution version of a dynamic filter.      Args:         inputs : unfiltered input [b, h, w, 1] only grayscale images.         filters : learned filters of [b, k, k, 1] (dynamically generated by the network).         out_channel (int): number of output channel.         kernel_shape: (h, w) tuple or a int.         stride: (h, w) tuple or a int.         padding (str): 'valid' or 'same'. Case insensitive.      Returns         tf.Tensor named ``output``.     \"\"\"      # tf.unstack only works with known batch_size :-(     batch_size, h, w, in_channel = inputs.get_shape().as_list()     stride = shape4d(stride)      inputs = tf.unstack(inputs)     filters = tf.reshape(filters, [batch_size] + shape2d(kernel_shape) + [in_channel, out_channel])     filters = tf.unstack(filters)      # this is ok as TF uses the cuda stream context     rsl = [tf.nn.conv2d(tf.reshape(d, [1, h, w, in_channel]),                         tf.reshape(k, [kernel_shape, kernel_shape, in_channel, out_channel]),                         stride, padding=\"SAME\") for d, k in zip(inputs, filters)]     rsl = tf.concat(rsl, axis=0, name='output')     return rsl",
            "def constant(times: np.ndarray, amp: complex) -> np.ndarray:     \"\"\"Continuous constant pulse.      Args:         times: Times to output pulse for.         amp: Complex pulse amplitude.     \"\"\"     return np.full(len(times), amp, dtype=np.complex_)"
        ],
        [
            "def __init__(self,                  post_clean_up: Callable[[Sequence[ops.Operation]], ops.OP_TREE                                 ] = lambda op_list: op_list                  ) -> None:         \"\"\"         Args:             post_clean_up: This function is called on each set of optimized                 operations before they are put into the circuit to replace the                 old operations.         \"\"\"         self.post_clean_up = post_clean_up",
            "def apply_operation(op_stack, out_stack):     \"\"\"     Apply operation to the first 2 items of the output queue      op_stack Deque (reference)     out_stack Deque (reference)     \"\"\"     out_stack.append(calc(out_stack.pop(), out_stack.pop(), op_stack.pop()))"
        ]
    ],
    [
        "how to make sure only letters are inputted python",
        [
            "def isAlphanum(c):     \"\"\"return true if the character is a letter, digit, underscore,            dollar sign, or non-ASCII character.     \"\"\"     return ((c >= 'a' and c <= 'z') or (c >= '0' and c <= '9') or             (c >= 'A' and c <= 'Z') or c == '_' or c == '$' or c == '\\\\' or (c is not None and ord(c) > 126));",
            "def strip_codes(s: Any) -> str:     \"\"\" Strip all color codes from a string.         Returns empty string for \"falsey\" inputs.     \"\"\"     return codepat.sub('', str(s) if (s or (s == 0)) else '')",
            "def isthaichar(ch: str) -> bool:     \"\"\"     Check if a character is Thai     \u0e40\u0e1b\u0e47\u0e19\u0e2d\u0e31\u0e01\u0e29\u0e23\u0e44\u0e17\u0e22\u0e2b\u0e23\u0e37\u0e2d\u0e44\u0e21\u0e48      :param str ch: input character     :return: True or False     \"\"\"     ch_val = ord(ch)     if ch_val >= 3584 and ch_val <= 3711:         return True     return False",
            "def return_letters_from_string(text):     \"\"\"Get letters from string only.\"\"\"     out = \"\"     for letter in text:         if letter.isalpha():             out += letter     return out",
            "def __contains__(self, char):  # noqa: D105         \"\"\"Implement the `in` keyword, searches the sequence.         \"\"\"         return len(char) <= len(self) and char in str(self.seq) * 2"
        ],
        [
            "def isAlphanum(c):     \"\"\"return true if the character is a letter, digit, underscore,            dollar sign, or non-ASCII character.     \"\"\"     return ((c >= 'a' and c <= 'z') or (c >= '0' and c <= '9') or             (c >= 'A' and c <= 'Z') or c == '_' or c == '$' or c == '\\\\' or (c is not None and ord(c) > 126));",
            "def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val",
            "def isthaichar(ch: str) -> bool:     \"\"\"     Check if a character is Thai     \u0e40\u0e1b\u0e47\u0e19\u0e2d\u0e31\u0e01\u0e29\u0e23\u0e44\u0e17\u0e22\u0e2b\u0e23\u0e37\u0e2d\u0e44\u0e21\u0e48      :param str ch: input character     :return: True or False     \"\"\"     ch_val = ord(ch)     if ch_val >= 3584 and ch_val <= 3711:         return True     return False",
            "def uniqueID(size=6, chars=string.ascii_uppercase + string.digits):     \"\"\"A quick and dirty way to get a unique string\"\"\"     return ''.join(random.choice(chars) for x in xrange(size))",
            "def unicode_is_ascii(u_string):     \"\"\"Determine if unicode string only contains ASCII characters.      :param str u_string: unicode string to check. Must be unicode         and not Python 2 `str`.     :rtype: bool     \"\"\"     assert isinstance(u_string, str)     try:         u_string.encode('ascii')         return True     except UnicodeEncodeError:         return False"
        ],
        [
            "def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)",
            "def return_letters_from_string(text):     \"\"\"Get letters from string only.\"\"\"     out = \"\"     for letter in text:         if letter.isalpha():             out += letter     return out"
        ]
    ],
    [
        "populate a tuple python",
        [
            "def get_value_tuple(self):         \"\"\"         Returns a tuple of the color's values (in order). For example,         an LabColor object will return (lab_l, lab_a, lab_b), where each         member of the tuple is the float value for said variable.         \"\"\"         retval = tuple()         for val in self.VALUES:             retval += (getattr(self, val),)         return retval",
            "def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value",
            "def ziptake(items_list, indexes_list):     \"\"\"     SeeAlso:         vt.ziptake     \"\"\"     return [take(list_, index_list)             for list_, index_list in zip(items_list, indexes_list)]",
            "def pairwise(iterable):     \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"     first, second = tee(iterable)     next(second, None)     return zip(first, second)",
            "def get_inputs_from_cm(index, cm):     \"\"\"Return indices of inputs to the node with the given index.\"\"\"     return tuple(i for i in range(cm.shape[0]) if cm[i][index])"
        ],
        [
            "def get_value_tuple(self):         \"\"\"         Returns a tuple of the color's values (in order). For example,         an LabColor object will return (lab_l, lab_a, lab_b), where each         member of the tuple is the float value for said variable.         \"\"\"         retval = tuple()         for val in self.VALUES:             retval += (getattr(self, val),)         return retval",
            "def pivot(self):         \"\"\"         transposes rows and columns         \"\"\"         self.op_data = [list(i) for i in zip(*self.ip_data)]",
            "def to_list(self):         \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"         return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],                 [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]",
            "def iter_items(iterable):     \"\"\" Iterate through all items (key-value pairs) within an iterable     dictionary-like object. If the object has a `keys` method, this is     used along with `__getitem__` to yield each pair in turn. If no     `keys` method exists, each iterable element is assumed to be a     2-tuple of key and value.     \"\"\"     if hasattr(iterable, \"keys\"):         for key in iterable.keys():             yield key, iterable[key]     else:         for key, value in iterable:             yield key, value",
            "def unique(self, values):         \"\"\"Place each entry in a table, while asserting that each entry occurs once\"\"\"         _, count = self.count()         if not np.array_equiv(count, 1):             raise ValueError(\"Not every entry in the table is assigned a unique value\")         return self.sum(values)"
        ],
        [
            "def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value",
            "def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))"
        ]
    ],
    [
        "how to remove /n in the end of string in python",
        [
            "def clean(s):   \"\"\"Removes trailing whitespace on each line.\"\"\"   lines = [l.rstrip() for l in s.split('\\n')]   return '\\n'.join(lines)",
            "def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string",
            "def text_remove_empty_lines(text):     \"\"\"     Whitespace normalization:        - Strip empty lines       - Strip trailing whitespace     \"\"\"     lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]     return \"\\n\".join(lines)",
            "def cleanLines(source, lineSep=os.linesep):     \"\"\"     :param source: some iterable source (list, file, etc)     :param lineSep: string of separators (chars) that must be removed     :return: list of non empty lines with removed separators     \"\"\"     stripped = (line.strip(lineSep) for line in source)     return (line for line in stripped if len(line) != 0)",
            "def fix_line_breaks(s):     \"\"\"     Convert \\r\\n and \\r to \\n chars. Strip any leading or trailing whitespace     on each line. Remove blank lines.     \"\"\"     l = s.splitlines()     x = [i.strip() for i in l]     x = [i for i in x if i]  # remove blank lines     return \"\\n\".join(x)"
        ],
        [
            "def remove_bad(string):     \"\"\"     remove problem characters from string     \"\"\"     remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']     for c in remove:         string = string.replace(c, '_')     return string",
            "def strip_spaces(s):     \"\"\" Strip excess spaces from a string \"\"\"     return u\" \".join([c for c in s.split(u' ') if c])",
            "def detokenize(s):     \"\"\" Detokenize a string by removing spaces before punctuation.\"\"\"     print(s)     s = re.sub(\"\\s+([;:,\\.\\?!])\", \"\\\\1\", s)     s = re.sub(\"\\s+(n't)\", \"\\\\1\", s)     return s",
            "def strip_spaces(x):     \"\"\"     Strips spaces     :param x:     :return:     \"\"\"     x = x.replace(b' ', b'')     x = x.replace(b'\\t', b'')     return x",
            "def drop_bad_characters(text):     \"\"\"Takes a text and drops all non-printable and non-ascii characters and     also any whitespace characters that aren't space.      :arg str text: the text to fix      :returns: text with all bad characters dropped      \"\"\"     # Strip all non-ascii and non-printable characters     text = ''.join([c for c in text if c in ALLOWED_CHARS])     return text"
        ],
        [
            "def replaceNewlines(string, newlineChar): \t\"\"\"There's probably a way to do this with string functions but I was lazy. \t\tReplace all instances of \\r or \\n in a string with something else.\"\"\" \tif newlineChar in string: \t\tsegments = string.split(newlineChar) \t\tstring = \"\" \t\tfor segment in segments: \t\t\tstring += segment \treturn string",
            "def normalize_value(text):     \"\"\"     This removes newlines and multiple spaces from a string.     \"\"\"     result = text.replace('\\n', ' ')     result = re.subn('[ ]{2,}', ' ', result)[0]     return result"
        ]
    ],
    [
        "how to put comma in number then right alignment in python",
        [
            "def concat_padded(base, *args):     \"\"\"     Concatenate string and zero-padded 4 digit number     \"\"\"     ret = base     for n in args:         if is_string(n):             ret = \"%s_%s\" % (ret, n)         else:             ret = \"%s_%04i\"  % (ret, n + 1)     return ret",
            "def _nth_str(n):     \"\"\"Return posessive form of numeral `n`: 1st, 2nd, 3rd, etc.\"\"\"     if n % 10 == 1 and n % 100 != 11:         return \"%dst\" % n     if n % 10 == 2 and n % 100 != 12:         return \"%dnd\" % n     if n % 10 == 3 and n % 100 != 13:         return \"%drd\" % n     return \"%dth\" % n",
            "def add_colons(s):     \"\"\"Add colons after every second digit.      This function is used in functions to prettify serials.      >>> add_colons('teststring')     'te:st:st:ri:ng'     \"\"\"     return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])",
            "def column(self, i):          \"\"\"from right\"\"\"         return ''.join([str(digitat2(r,i)) for r in self])",
            "def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string"
        ],
        [
            "def column(self, i):          \"\"\"from right\"\"\"         return ''.join([str(digitat2(r,i)) for r in self])",
            "def _nth_str(n):     \"\"\"Return posessive form of numeral `n`: 1st, 2nd, 3rd, etc.\"\"\"     if n % 10 == 1 and n % 100 != 11:         return \"%dst\" % n     if n % 10 == 2 and n % 100 != 12:         return \"%dnd\" % n     if n % 10 == 3 and n % 100 != 13:         return \"%drd\" % n     return \"%dth\" % n",
            "def concat_padded(base, *args):     \"\"\"     Concatenate string and zero-padded 4 digit number     \"\"\"     ret = base     for n in args:         if is_string(n):             ret = \"%s_%s\" % (ret, n)         else:             ret = \"%s_%04i\"  % (ret, n + 1)     return ret",
            "def _naturalize_numbers(self, string):         \"\"\"         Makes any integers into very zero-padded numbers.         e.g. '1' becomes '00000001'.         \"\"\"          def naturalize_int_match(match):             return '%08d' % (int(match.group(0)),)          string = re.sub(r'\\d+', naturalize_int_match, string)          return string",
            "def try_cast_int(s):     \"\"\"(str) -> int     All the digits in a given string are concatenated and converted into a single number.     \"\"\"     try:         temp = re.findall('\\d', str(s))         temp = ''.join(temp)         return int(temp)     except:         return s"
        ],
        [
            "def add_colons(s):     \"\"\"Add colons after every second digit.      This function is used in functions to prettify serials.      >>> add_colons('teststring')     'te:st:st:ri:ng'     \"\"\"     return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])",
            "def draw_header(self, stream, header):         \"\"\"Draw header with underline\"\"\"         stream.writeln('=' * (len(header) + 4))         stream.writeln('| ' + header + ' |')         stream.writeln('=' * (len(header) + 4))         stream.writeln()"
        ]
    ],
    [
        "python are inputs string by default",
        [
            "def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val",
            "def chk_enum_arg(s):     \"\"\"Checks if the string `s` is a valid enum string.      Return True or False.\"\"\"      if len(s) == 0 or s[0].isspace() or s[-1].isspace():         return False     else:         return True",
            "def convertToNative(self, aVal):         \"\"\" Convert to native bool; interpret certain strings. \"\"\"         if aVal is None:             return None         if isinstance(aVal, bool): return aVal         # otherwise interpret strings         return str(aVal).lower() in ('1','on','yes','true')",
            "def boolean(value):     \"\"\"     Configuration-friendly boolean type converter.      Supports both boolean-valued and string-valued inputs (e.g. from env vars).      \"\"\"     if isinstance(value, bool):         return value      if value == \"\":         return False      return strtobool(value)",
            "def _check_and_convert_bools(self):         \"\"\"Replace boolean variables by the characters 'F'/'T'         \"\"\"         replacements = {             True: 'T',             False: 'F',         }          for key in self.bools:             if isinstance(self[key], bool):                 self[key] = replacements[self[key]]"
        ],
        [
            "def boolean(value):     \"\"\"     Configuration-friendly boolean type converter.      Supports both boolean-valued and string-valued inputs (e.g. from env vars).      \"\"\"     if isinstance(value, bool):         return value      if value == \"\":         return False      return strtobool(value)",
            "def chk_enum_arg(s):     \"\"\"Checks if the string `s` is a valid enum string.      Return True or False.\"\"\"      if len(s) == 0 or s[0].isspace() or s[-1].isspace():         return False     else:         return True",
            "def type_converter(text):     \"\"\" I convert strings into integers, floats, and strings! \"\"\"     if text.isdigit():         return int(text), int      try:         return float(text), float     except ValueError:         return text, STRING_TYPE",
            "def convertToNative(self, aVal):         \"\"\" Convert to native bool; interpret certain strings. \"\"\"         if aVal is None:             return None         if isinstance(aVal, bool): return aVal         # otherwise interpret strings         return str(aVal).lower() in ('1','on','yes','true')",
            "def validate_positive_integer(option, value):     \"\"\"Validate that 'value' is a positive integer, which does not include 0.     \"\"\"     val = validate_integer(option, value)     if val <= 0:         raise ValueError(\"The value of %s must be \"                          \"a positive integer\" % (option,))     return val"
        ],
        [
            "def _stdin_(p):     \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"     _v = sys.version[0]     return input(p) if _v is '3' else raw_input(p)",
            "def get_input(input_func, input_str):     \"\"\"     Get input from the user given an input function and an input string     \"\"\"     val = input_func(\"Please enter your {0}: \".format(input_str))     while not val or not len(val.strip()):         val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))     return val"
        ]
    ],
    [
        "python hw to check if string is integer",
        [
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False",
            "def ishex(obj):     \"\"\"     Test if the argument is a string representing a valid hexadecimal digit.      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return isinstance(obj, str) and (len(obj) == 1) and (obj in string.hexdigits)",
            "def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)",
            "def is_valid(number):     \"\"\"determines whether the card number is valid.\"\"\"     n = str(number)     if not n.isdigit():         return False     return int(n[-1]) == get_check_digit(n[:-1])",
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0"
        ],
        [
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False",
            "def is_valid(number):     \"\"\"determines whether the card number is valid.\"\"\"     n = str(number)     if not n.isdigit():         return False     return int(n[-1]) == get_check_digit(n[:-1])",
            "def is_integer(obj):     \"\"\"Is this an integer.      :param object obj:     :return:     \"\"\"     if PYTHON3:         return isinstance(obj, int)     return isinstance(obj, (int, long))",
            "def ishex(obj):     \"\"\"     Test if the argument is a string representing a valid hexadecimal digit.      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return isinstance(obj, str) and (len(obj) == 1) and (obj in string.hexdigits)"
        ],
        [
            "def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)",
            "def str2int(string_with_int):     \"\"\" Collect digits from a string \"\"\"     return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)"
        ]
    ],
    [
        "how to say \"anything else\" in python",
        [
            "def show_help(self):         \"\"\"Prints to stdout help on how to answer properly\"\"\"         print(\"Sorry, not well understood.\")         print(\"- use\", str(self.yes_input), \"to answer 'YES'\")         print(\"- use\", str(self.no_input), \"to answer 'NO'\")",
            "def chk_enum_arg(s):     \"\"\"Checks if the string `s` is a valid enum string.      Return True or False.\"\"\"      if len(s) == 0 or s[0].isspace() or s[-1].isspace():         return False     else:         return True",
            "def __exit__(self, type, value, traceback):         \"\"\"When the `with` statement ends.\"\"\"          if not self.asarfile:             return          self.asarfile.close()         self.asarfile = None",
            "def normalize_multiline(line):     \"\"\"Normalize multiline-related code that will cause syntax error.      This is for purposes of checking syntax.      \"\"\"     if line.startswith('def ') and line.rstrip().endswith(':'):         return line + ' pass'     elif line.startswith('return '):         return 'def _(): ' + line     elif line.startswith('@'):         return line + 'def _(): pass'     elif line.startswith('class '):         return line + ' pass'     elif line.startswith(('if ', 'elif ', 'for ', 'while ')):         return line + ' pass'     else:         return line",
            "def good(txt):     \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"      print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))     sys.stdout.flush()"
        ],
        [
            "def hard_equals(a, b):     \"\"\"Implements the '===' operator.\"\"\"     if type(a) != type(b):         return False     return a == b",
            "def notin(arg, values):     \"\"\"     Like isin, but checks whether this expression's value(s) are not     contained in the passed values. See isin docs for full usage.     \"\"\"     op = ops.NotContains(arg, values)     return op.to_expr()",
            "def isreal(obj):     \"\"\"     Test if the argument is a real number (float or integer).      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return (         (obj is not None)         and (not isinstance(obj, bool))         and isinstance(obj, (int, float))     )",
            "def _not_none(items):     \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"     if not isinstance(items, (tuple, list)):         items = (items,)     return all(item is not _none for item in items)",
            "def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]"
        ],
        [
            "def show_help(self):         \"\"\"Prints to stdout help on how to answer properly\"\"\"         print(\"Sorry, not well understood.\")         print(\"- use\", str(self.yes_input), \"to answer 'YES'\")         print(\"- use\", str(self.no_input), \"to answer 'NO'\")",
            "def pause(msg=\"Press Enter to Continue...\"):     \"\"\"press to continue\"\"\"     print('\\n' + Fore.YELLOW + msg + Fore.RESET, end='')     input()"
        ]
    ],
    [
        "gdb check python support",
        [
            "def get_pants_configdir():   \"\"\"Return the pants global config directory.\"\"\"   # Follow the unix XDB base spec: http://standards.freedesktop.org/basedir-spec/latest/index.html.   config_home = os.environ.get('XDG_CONFIG_HOME')   if not config_home:     config_home = '~/.config'   return os.path.expanduser(os.path.join(config_home, 'pants'))",
            "def get_complete_version(version=None):     \"\"\"Returns a tuple of the graphene version. If version argument is non-empty,     then checks for correctness of the tuple provided.     \"\"\"     if version is None:         from graphene import VERSION as version     else:         assert len(version) == 5         assert version[3] in (\"alpha\", \"beta\", \"rc\", \"final\")      return version",
            "def check_new_version_available(this_version):     \"\"\"     Checks if a newer version of Zappa is available.      Returns True is updateable, else False.      \"\"\"     import requests      pypi_url = 'https://pypi.python.org/pypi/Zappa/json'     resp = requests.get(pypi_url, timeout=1.5)     top_version = resp.json()['info']['version']      return this_version != top_version",
            "def getSystemVariable(self, remote, name):         \"\"\"Get single system variable from CCU / Homegear\"\"\"         if self._server is not None:             return self._server.getSystemVariable(remote, name)",
            "def gtype_to_python(gtype):         \"\"\"Map a gtype to the name of the Python type we use to represent it.          \"\"\"          fundamental = gobject_lib.g_type_fundamental(gtype)          if gtype in GValue._gtype_to_python:             return GValue._gtype_to_python[gtype]         if fundamental in GValue._gtype_to_python:             return GValue._gtype_to_python[fundamental]         return '<unknown type>'"
        ],
        [
            "def column_exists(cr, table, column):     \"\"\" Check whether a certain column exists \"\"\"     cr.execute(         'SELECT count(attname) FROM pg_attribute '         'WHERE attrelid = '         '( SELECT oid FROM pg_class WHERE relname = %s ) '         'AND attname = %s',         (table, column))     return cr.fetchone()[0] == 1",
            "def is_installable(self, model_index):         \"\"\" \"\"\"         row = model_index.row()         status = self._rows[row][C.COL_STATUS]         return status == C.NOT_INSTALLED",
            "def quote_names(db, names):     \"\"\"psycopg2 doesn't know how to quote identifier names, so we ask the server\"\"\"     c = db.cursor()     c.execute(\"SELECT pg_catalog.quote_ident(n) FROM pg_catalog.unnest(%s::text[]) n\", [list(names)])     return [name for (name,) in c]",
            "def close( self ):         \"\"\"         Close the db and release memory         \"\"\"         if self.db is not None:             self.db.commit()             self.db.close()             self.db = None          return",
            "def __init__(self, db):         \"\"\"         Connect to the Salesforce API.         \"\"\"         self.db = db         self.query = None         self.session = db.sf_session         self.rowcount = None         self.first_row = None         self.lastrowid = None  # not moved to driver because INSERT is implemented here         self.cursor = self.db.connection.cursor()"
        ],
        [
            "def get_complete_version(version=None):     \"\"\"Returns a tuple of the graphene version. If version argument is non-empty,     then checks for correctness of the tuple provided.     \"\"\"     if version is None:         from graphene import VERSION as version     else:         assert len(version) == 5         assert version[3] in (\"alpha\", \"beta\", \"rc\", \"final\")      return version",
            "def gtype_to_python(gtype):         \"\"\"Map a gtype to the name of the Python type we use to represent it.          \"\"\"          fundamental = gobject_lib.g_type_fundamental(gtype)          if gtype in GValue._gtype_to_python:             return GValue._gtype_to_python[gtype]         if fundamental in GValue._gtype_to_python:             return GValue._gtype_to_python[fundamental]         return '<unknown type>'"
        ]
    ],
    [
        "python send print to logger",
        [
            "def logger(message, level=10):     \"\"\"Handle logging.\"\"\"     logging.getLogger(__name__).log(level, str(message))",
            "def log_no_newline(self, msg):       \"\"\" print the message to the predefined log file without newline \"\"\"       self.print2file(self.logfile, False, False, msg)",
            "def log(self, level, msg=None, *args, **kwargs):         \"\"\"Writes log out at any arbitray level.\"\"\"          return self._log(level, msg, args, kwargs)",
            "def configure(logger=None):     \"\"\"Pass stump a logger to use. If no logger is supplied, a basic logger     of level INFO will print to stdout.      \"\"\"     global LOGGER     if logger is None:         LOGGER = logging.basicConfig(stream=sys.stdout, level=logging.INFO)     else:         LOGGER = logger",
            "def info(self, text): \t\t\"\"\" Ajout d'un message de log de type INFO \"\"\" \t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))"
        ],
        [
            "def log_no_newline(self, msg):       \"\"\" print the message to the predefined log file without newline \"\"\"       self.print2file(self.logfile, False, False, msg)",
            "def pstd(self, *args, **kwargs):         \"\"\" Console to STDOUT \"\"\"         kwargs['file'] = self.out         self.print(*args, **kwargs)         sys.stdout.flush()",
            "def logger(message, level=10):     \"\"\"Handle logging.\"\"\"     logging.getLogger(__name__).log(level, str(message))",
            "def log(self, level, msg=None, *args, **kwargs):         \"\"\"Writes log out at any arbitray level.\"\"\"          return self._log(level, msg, args, kwargs)",
            "def configure(logger=None):     \"\"\"Pass stump a logger to use. If no logger is supplied, a basic logger     of level INFO will print to stdout.      \"\"\"     global LOGGER     if logger is None:         LOGGER = logging.basicConfig(stream=sys.stdout, level=logging.INFO)     else:         LOGGER = logger"
        ],
        [
            "def debug(self, text): \t\t\"\"\" Ajout d'un message de log de type DEBUG \"\"\" \t\tself.logger.debug(\"{}{}\".format(self.message_prefix, text))",
            "def info(self, text): \t\t\"\"\" Ajout d'un message de log de type INFO \"\"\" \t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))"
        ]
    ],
    [
        "python dictionary key present or not",
        [
            "def __contains__(self, key):         \"\"\"         Invoked when determining whether a specific key is in the dictionary         using `key in d`.          The key is looked up case-insensitively.         \"\"\"         k = self._real_key(key)         return k in self._data",
            "def __contains__(self, key):         \"\"\" Tests if a key is contained in the store.              May test againsts self.defaults              :param str value: Value         \"\"\"         if self._haveKey(key) or key in self.defaults:             return True         else:             return False",
            "def key_of(d):     \"\"\"     Returns the key of a single element dict.     \"\"\"     if len(d) > 1 and not type(d) == dict():         raise ValueError('key_of(d) may only except single element dict')     else:         return keys_of(d)[0]",
            "def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]",
            "def _has(self, key, exact=0):          \"\"\"Returns false if key is not found or is ambiguous\"\"\"          if not exact:             try:                 key = self.getfullkey(key)                 return 1             except KeyError:                 return 0         else:             return key in self.data"
        ],
        [
            "def _remove_dict_keys_with_value(dict_, val):   \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"   return {k: v for k, v in dict_.items() if v is not val}",
            "def __contains__(self, key):         \"\"\"         Invoked when determining whether a specific key is in the dictionary         using `key in d`.          The key is looked up case-insensitively.         \"\"\"         k = self._real_key(key)         return k in self._data",
            "def is_valid_row(cls, row):         \"\"\"Indicates whether or not the given row contains valid data.\"\"\"         for k in row.keys():             if row[k] is None:                 return False         return True",
            "def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]",
            "def get_single_item(d):     \"\"\"Get an item from a dict which contains just one item.\"\"\"     assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)     return next(six.iteritems(d))"
        ],
        [
            "def _has(self, key, exact=0):          \"\"\"Returns false if key is not found or is ambiguous\"\"\"          if not exact:             try:                 key = self.getfullkey(key)                 return 1             except KeyError:                 return 0         else:             return key in self.data",
            "def __contains__(self, key):         \"\"\" Tests if a key is contained in the store.              May test againsts self.defaults              :param str value: Value         \"\"\"         if self._haveKey(key) or key in self.defaults:             return True         else:             return False"
        ]
    ],
    [
        "common elements in 2 array python",
        [
            "def compare(a, b):     \"\"\"      Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))     \"\"\"     s=0     for i in range(len(a)):         s=s+abs(a[i]-b[i])     return s",
            "def dims_intersect(self):         \"\"\"Dimensions of the arrays in this list that are used in all arrays         \"\"\"         return set.intersection(*map(             set, (getattr(arr, 'dims_intersect', arr.dims) for arr in self)))",
            "def equal(list1, list2):     \"\"\" takes flags returns indexes of True values \"\"\"     return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]",
            "def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)",
            "def find_index(array, x):     \"\"\"     Locate the leftmost value exactly equal to x.      :type array: list     :param array: an iterable object that support inex      :param x: a comparable value      **\u4e2d\u6587\u6587\u6863**      \u8fd4\u56de\u7b2c\u4e00\u4e2a\u503c\u7b49\u4e8ex\u7684\u5143\u7d20\u7684\u7d22\u5f15\u3002     \"\"\"     i = bisect.bisect_left(array, x)     if i != len(array) and array[i] == x:         return i     raise ValueError"
        ],
        [
            "def _check_elements_equal(lst):     \"\"\"     Returns true if all of the elements in the list are equal.     \"\"\"     assert isinstance(lst, list), \"Input value must be a list.\"     return not lst or lst.count(lst[0]) == len(lst)",
            "def dims_intersect(self):         \"\"\"Dimensions of the arrays in this list that are used in all arrays         \"\"\"         return set.intersection(*map(             set, (getattr(arr, 'dims_intersect', arr.dims) for arr in self)))",
            "def unique_element(ll):     \"\"\" returns unique elements from a list preserving the original order \"\"\"     seen = {}     result = []     for item in ll:         if item in seen:             continue         seen[item] = 1         result.append(item)     return result",
            "def equal(list1, list2):     \"\"\" takes flags returns indexes of True values \"\"\"     return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]",
            "def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]"
        ],
        [
            "def compare(a, b):     \"\"\"      Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))     \"\"\"     s=0     for i in range(len(a)):         s=s+abs(a[i]-b[i])     return s",
            "def full_like(array, value, dtype=None):     \"\"\" Create a shared memory array with the same shape and type as a given array, filled with `value`.     \"\"\"     shared = empty_like(array, dtype)     shared[:] = value     return shared"
        ]
    ],
    [
        "python create path folders",
        [
            "def parent_directory(self):         \"\"\"Change working directory to parent directory\"\"\"         self.chdir(os.path.join(getcwd_or_home(), os.path.pardir))",
            "def go_to_parent_directory(self):         \"\"\"Go to parent directory\"\"\"         self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))",
            "def examples(directory):     \"\"\"     Generate example strategies to target folder     \"\"\"     source_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), \"examples\")      try:         shutil.copytree(source_dir, os.path.join(directory, \"examples\"))     except OSError as e:         if e.errno == errno.EEXIST:             six.print_(\"Folder examples is exists.\")",
            "def abspath(*path):     \"\"\"A method to determine absolute path for a given relative path to the     directory where this setup.py script is located\"\"\"     setup_dir = os.path.dirname(os.path.abspath(__file__))     return os.path.join(setup_dir, *path)",
            "def normalize_path(filename):     \"\"\"Normalize a file/dir name for comparison purposes\"\"\"     return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))"
        ],
        [
            "def examples(directory):     \"\"\"     Generate example strategies to target folder     \"\"\"     source_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), \"examples\")      try:         shutil.copytree(source_dir, os.path.join(directory, \"examples\"))     except OSError as e:         if e.errno == errno.EEXIST:             six.print_(\"Folder examples is exists.\")",
            "def case_insensitive_rename(src, dst):     \"\"\"A hack to allow us to rename paths in a case-insensitive filesystem like HFS.\"\"\"     temp_dir = tempfile.mkdtemp()     shutil.rmtree(temp_dir)     shutil.move(src, temp_dir)     shutil.move(temp_dir, dst)",
            "def normalize_path(filename):     \"\"\"Normalize a file/dir name for comparison purposes\"\"\"     return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))",
            "def is_readable_dir(path):   \"\"\"Returns whether a path names an existing directory we can list and read files from.\"\"\"   return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)",
            "def contained_in(filename, directory):     \"\"\"Test if a file is located within the given directory.\"\"\"     filename = os.path.normcase(os.path.abspath(filename))     directory = os.path.normcase(os.path.abspath(directory))     return os.path.commonprefix([filename, directory]) == directory"
        ],
        [
            "def abspath(*path):     \"\"\"A method to determine absolute path for a given relative path to the     directory where this setup.py script is located\"\"\"     setup_dir = os.path.dirname(os.path.abspath(__file__))     return os.path.join(setup_dir, *path)",
            "def get_module_path(modname):     \"\"\"Return module *modname* base path\"\"\"     return osp.abspath(osp.dirname(sys.modules[modname].__file__))"
        ]
    ],
    [
        "how to set the axis in the scatter python",
        [
            "def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)",
            "def horizontal_line(ax, scale, i, **kwargs):     \"\"\"     Draws the i-th horizontal line parallel to the lower axis.      Parameters     ----------     ax: Matplotlib AxesSubplot         The subplot to draw on.     scale: float, 1.0         Simplex scale size.     i: float         The index of the line to draw     kwargs: Dictionary         Any kwargs to pass through to Matplotlib.     \"\"\"      p1 = (0, i, scale - i)     p2 = (scale - i, i, 0)     line(ax, p1, p2, **kwargs)",
            "def set_axis_options(self, row, column, text):         \"\"\"Set additionnal options as plain text.\"\"\"          subplot = self.get_subplot_at(row, column)         subplot.set_axis_options(text)",
            "def basic():     \"\"\"Set up a basic stereonet and plot the same data each time.\"\"\"     fig, ax = mplstereonet.subplots()      strike, dip = 315, 30     ax.plane(strike, dip, color='lightblue')     ax.pole(strike, dip, color='green', markersize=15)     ax.rake(strike, dip, 40, marker='*', markersize=20, color='green')      # Make a bit of room for the title...     fig.subplots_adjust(top=0.8)      return ax",
            "def set_scalebar_for_all(self, row_column_list=None,                              location='lower right'):         \"\"\"Show marker area scale for subplots.          :param row_column_list: a list containing (row, column) tuples to             specify the subplots, or None to indicate *all* subplots.         :param location: the location of the label inside the plot.  May             be one of 'center', 'upper right', 'lower right', 'upper             left', 'lower left'.          \"\"\"         if row_column_list is None:             for subplot in self.subplots:                 subplot.set_scalebar(location)         else:             for row, column in row_column_list:                 subplot = self.get_subplot_at(row, column)                 subplot.set_scalebar(location)"
        ],
        [
            "def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)",
            "def set_axis_options(self, row, column, text):         \"\"\"Set additionnal options as plain text.\"\"\"          subplot = self.get_subplot_at(row, column)         subplot.set_axis_options(text)",
            "def horizontal_line(ax, scale, i, **kwargs):     \"\"\"     Draws the i-th horizontal line parallel to the lower axis.      Parameters     ----------     ax: Matplotlib AxesSubplot         The subplot to draw on.     scale: float, 1.0         Simplex scale size.     i: float         The index of the line to draw     kwargs: Dictionary         Any kwargs to pass through to Matplotlib.     \"\"\"      p1 = (0, i, scale - i)     p2 = (scale - i, i, 0)     line(ax, p1, p2, **kwargs)",
            "def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()",
            "def basic():     \"\"\"Set up a basic stereonet and plot the same data each time.\"\"\"     fig, ax = mplstereonet.subplots()      strike, dip = 315, 30     ax.plane(strike, dip, color='lightblue')     ax.pole(strike, dip, color='green', markersize=15)     ax.rake(strike, dip, 40, marker='*', markersize=20, color='green')      # Make a bit of room for the title...     fig.subplots_adjust(top=0.8)      return ax"
        ],
        [
            "def set_scalebar_for_all(self, row_column_list=None,                              location='lower right'):         \"\"\"Show marker area scale for subplots.          :param row_column_list: a list containing (row, column) tuples to             specify the subplots, or None to indicate *all* subplots.         :param location: the location of the label inside the plot.  May             be one of 'center', 'upper right', 'lower right', 'upper             left', 'lower left'.          \"\"\"         if row_column_list is None:             for subplot in self.subplots:                 subplot.set_scalebar(location)         else:             for row, column in row_column_list:                 subplot = self.get_subplot_at(row, column)                 subplot.set_scalebar(location)",
            "def ytickvals(self, values, index=1):         \"\"\"Set the tick values.          Parameters         ----------         values : array-like          Returns         -------         Chart          \"\"\"         self.layout['yaxis' + str(index)]['tickvals'] = values         return self"
        ]
    ],
    [
        "change png pil image to white background stackoverflow python",
        [
            "def add_bg(img, padding, color=COL_WHITE):     \"\"\"     Adds a padding to the given image as background of specified color      :param img: Input image.     :param padding: constant padding around the image.     :param color: background color that needs to filled for the newly padded region.     :return: New image with background.     \"\"\"     img = gray3(img)     h, w, d = img.shape     new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]     new_img = new_img.astype(np.uint8)     set_img_box(new_img, (padding, padding, w, h), img)     return new_img",
            "def screen_cv2(self):         \"\"\"cv2 Image of current window screen\"\"\"         pil_image = self.screen.convert('RGB')         cv2_image = np.array(pil_image)         pil_image.close()         # Convert RGB to BGR          cv2_image = cv2_image[:, :, ::-1]         return cv2_image",
            "def gray2bgr(img):     \"\"\"Convert a grayscale image to BGR image.      Args:         img (ndarray or str): The input image.      Returns:         ndarray: The converted BGR image.     \"\"\"     img = img[..., None] if img.ndim == 2 else img     out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)     return out_img",
            "def hflip(img):     \"\"\"Horizontally flip the given PIL Image.      Args:         img (PIL Image): Image to be flipped.      Returns:         PIL Image:  Horizontall flipped image.     \"\"\"     if not _is_pil_image(img):         raise TypeError('img should be PIL Image. Got {}'.format(type(img)))      return img.transpose(Image.FLIP_LEFT_RIGHT)",
            "def imshow(self, canvas, X, extent=None, label=None, vmin=None, vmax=None, **kwargs):         \"\"\"         Show the image stored in X on the canvas.                  The origin of the image show is (0,0), such that X[0,0] gets plotted at [0,0] of the image!                  the kwargs are plotting library specific kwargs!         \"\"\"         raise NotImplementedError(\"Implement all plot functions in AbstractPlottingLibrary in order to use your own plotting library\")"
        ],
        [
            "def screen_cv2(self):         \"\"\"cv2 Image of current window screen\"\"\"         pil_image = self.screen.convert('RGB')         cv2_image = np.array(pil_image)         pil_image.close()         # Convert RGB to BGR          cv2_image = cv2_image[:, :, ::-1]         return cv2_image",
            "def read_img(path):     \"\"\" Reads image specified by path into numpy.ndarray\"\"\"     img = cv2.resize(cv2.imread(path, 0), (80, 30)).astype(np.float32) / 255     img = np.expand_dims(img.transpose(1, 0), 0)     return img",
            "def resize(src, size, interpolation=cv2.INTER_LINEAR):     \"\"\"Decode image from str buffer.     Wrapper for cv2.imresize that uses mx.nd.NDArray      Parameters     ----------     src : NDArray         image in (width, height, channels)     size : tuple         target size in (width, height)     interpolation : int         same as interpolation for cv2.imresize      Returns     -------     img : NDArray         resized image     \"\"\"     hdl = NDArrayHandle()     check_call(_LIB.MXCVResize(src.handle, mx_uint(size[0]), mx_uint(size[1]),                                interpolation, ctypes.byref(hdl)))     return mx.nd.NDArray(hdl)",
            "def imdecode(image_path):     \"\"\"Return BGR image read by opencv\"\"\"     import os     assert os.path.exists(image_path), image_path + ' not found'     im = cv2.imread(image_path)     return im",
            "def gray2bgr(img):     \"\"\"Convert a grayscale image to BGR image.      Args:         img (ndarray or str): The input image.      Returns:         ndarray: The converted BGR image.     \"\"\"     img = img[..., None] if img.ndim == 2 else img     out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)     return out_img"
        ],
        [
            "def hflip(img):     \"\"\"Horizontally flip the given PIL Image.      Args:         img (PIL Image): Image to be flipped.      Returns:         PIL Image:  Horizontall flipped image.     \"\"\"     if not _is_pil_image(img):         raise TypeError('img should be PIL Image. Got {}'.format(type(img)))      return img.transpose(Image.FLIP_LEFT_RIGHT)",
            "def add_bg(img, padding, color=COL_WHITE):     \"\"\"     Adds a padding to the given image as background of specified color      :param img: Input image.     :param padding: constant padding around the image.     :param color: background color that needs to filled for the newly padded region.     :return: New image with background.     \"\"\"     img = gray3(img)     h, w, d = img.shape     new_img = np.ones((h + 2*padding, w + 2*padding, d)) * color[:d]     new_img = new_img.astype(np.uint8)     set_img_box(new_img, (padding, padding, w, h), img)     return new_img"
        ]
    ],
    [
        "python run command and close it",
        [
            "def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]",
            "def disown(cmd):     \"\"\"Call a system command in the background,        disown it and hide it's output.\"\"\"     subprocess.Popen(cmd,                      stdout=subprocess.DEVNULL,                      stderr=subprocess.DEVNULL)",
            "def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)",
            "def kill_mprocess(process):     \"\"\"kill process     Args:         process - Popen object for process     \"\"\"     if process and proc_alive(process):         process.terminate()         process.communicate()     return not proc_alive(process)",
            "def call_out(command):   \"\"\"   Run the given command (with shell=False) and return a tuple of   (int returncode, str output). Strip the output of enclosing whitespace.   \"\"\"   # start external command process   p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    # get outputs   out, _ = p.communicate()    return p.returncode, out.strip()"
        ],
        [
            "def disown(cmd):     \"\"\"Call a system command in the background,        disown it and hide it's output.\"\"\"     subprocess.Popen(cmd,                      stdout=subprocess.DEVNULL,                      stderr=subprocess.DEVNULL)",
            "def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]",
            "def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)",
            "def __init__(self, pidfile, daemonize=True, root=False, root_chk_argv=True, stdin=\"/dev/null\", stdout=\"/dev/null\", stderr=\"/dev/null\"): \t\t\"\"\" \t\tMake our daemon instance. \t\tpidfile: the file we're going to store the process id in. ex: /tmp/matt-daemon.pid \t\troot:    does this script require root? True if it does, False if it doesn't. Will be enforced. \t\troot_chk_argv:  does the script require '--requires-root' in sys.argv to run as root? (usage is good) \t\tstdin:   where the script gets stdin from. \"/dev/null\", \"/dev/stdin\", etc. \t\tstdout:  where the script writes stdout. \"/dev/null\", \"/dev/stdout\", etc. \t\tstderr:  where the script writes stderr. \"/dev/null\", \"/dev/stderr\", etc. \t\t\"\"\" \t\t# Enforce root usage or non-usage. \t\tRootCheck.check(root, check_argv=root_chk_argv) \t\tself.pidfile = pidfile \t\tself.should_daemonize = daemonize \t\tself.stdin = stdin \t\tself.stdout = stdout \t\tself.stderr = stderr",
            "def call_out(command):   \"\"\"   Run the given command (with shell=False) and return a tuple of   (int returncode, str output). Strip the output of enclosing whitespace.   \"\"\"   # start external command process   p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)    # get outputs   out, _ = p.communicate()    return p.returncode, out.strip()"
        ],
        [
            "def close( self ):         \"\"\"         Close the db and release memory         \"\"\"         if self.db is not None:             self.db.commit()             self.db.close()             self.db = None          return",
            "def kill_mprocess(process):     \"\"\"kill process     Args:         process - Popen object for process     \"\"\"     if process and proc_alive(process):         process.terminate()         process.communicate()     return not proc_alive(process)"
        ]
    ],
    [
        "how to keep calling a function forever in python",
        [
            "def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)",
            "def Join(self):     \"\"\"Waits until all outstanding tasks are completed.\"\"\"      for _ in range(self.JOIN_TIMEOUT_DECISECONDS):       if self._queue.empty() and not self.busy_threads:         return       time.sleep(0.1)      raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)",
            "def blocking(func, *args, **kwargs):     \"\"\"Run a function that uses blocking IO.      The function is run in the IO thread pool.     \"\"\"     pool = get_io_pool()     fut = pool.submit(func, *args, **kwargs)     return fut.result()",
            "def repeat(f, dt=1/60):     \"\"\" \u91cd\u590d\u6267\u884c\u51fd\u6570f\uff0c\u65f6\u95f4\u95f4\u9694dt \"\"\"     stop(f)     pyglet.clock.schedule_interval(f, dt)",
            "def wait_until_exit(self):         \"\"\" Wait until thread exit              Used for testing purpose only         \"\"\"          if self._timeout is None:             raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\")          self._thread.join()         self.stop()"
        ],
        [
            "def speedtest(func, *args, **kwargs):     \"\"\" Test the speed of a function. \"\"\"     n = 100     start = time.time()     for i in range(n): func(*args,**kwargs)     end = time.time()     return (end-start)/n",
            "def needs_check(self):         \"\"\"         Check if enough time has elapsed to perform a check().          If this time has elapsed, a state change check through         has_state_changed() should be performed and eventually a sync().          :rtype: boolean         \"\"\"         if self.lastcheck is None:             return True         return time.time() - self.lastcheck >= self.ipchangedetection_sleep",
            "def _apply_list(self, methods):     \"\"\"Return a single callable that applies a list of methods to a value.      If a method returns None, the last value is kept; if it returns     some other value, that replaces the last value.  Exceptions are     not caught.     \"\"\"     def call(value):       for method in methods:         newvalue = method(self, value)         if newvalue is not None:           value = newvalue       return value     return call",
            "def blocking(func, *args, **kwargs):     \"\"\"Run a function that uses blocking IO.      The function is run in the IO thread pool.     \"\"\"     pool = get_io_pool()     fut = pool.submit(func, *args, **kwargs)     return fut.result()",
            "def repeat(f, dt=1/60):     \"\"\" \u91cd\u590d\u6267\u884c\u51fd\u6570f\uff0c\u65f6\u95f4\u95f4\u9694dt \"\"\"     stop(f)     pyglet.clock.schedule_interval(f, dt)"
        ],
        [
            "def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)",
            "def seconds(num):     \"\"\"     Pause for this many seconds     \"\"\"     now = pytime.time()     end = now + num     until(end)"
        ]
    ],
    [
        "python3 requests response text",
        [
            "def __send_request(self, url, params=None):         \"\"\"Send request\"\"\"          r = self.fetch(url, payload=params)         return r.text",
            "def url_read_text(url, verbose=True):     r\"\"\"     Directly reads text data from url     \"\"\"     data = url_read(url, verbose)     text = data.decode('utf8')     return text",
            "def load_data(url): \t\"\"\" \t\"\"\"  \t# http request \tr = requests.get(url)  \t# decode to json \tdata = r.json()  \treturn data",
            "def post_sea_resource(url, body):     \"\"\"     Get the requested resource using the Seattle account     :returns: http response with content in json     \"\"\"     response = None     response = TrumbaSea_DAO().postURL(         url,         {\"Content-Type\": \"application/json\"},         body)     _log_json_resp(\"Seattle\", url, body, response)     return response",
            "def wget(url):     \"\"\"     Download the page into a string     \"\"\"     import urllib.parse     request = urllib.request.urlopen(url)     filestring = request.read()     return filestring"
        ],
        [
            "def load_data(url): \t\"\"\" \t\"\"\"  \t# http request \tr = requests.get(url)  \t# decode to json \tdata = r.json()  \treturn data",
            "def __send_request(self, url, params=None):         \"\"\"Send request\"\"\"          r = self.fetch(url, payload=params)         return r.text",
            "def get_jsonparsed_data(url):     \"\"\"Receive the content of ``url``, parse it as JSON and return the        object.     \"\"\"     response = urlopen(url)     data = response.read().decode('utf-8')     return json.loads(data)",
            "def wget(url):     \"\"\"     Download the page into a string     \"\"\"     import urllib.parse     request = urllib.request.urlopen(url)     filestring = request.read()     return filestring",
            "def post_sea_resource(url, body):     \"\"\"     Get the requested resource using the Seattle account     :returns: http response with content in json     \"\"\"     response = None     response = TrumbaSea_DAO().postURL(         url,         {\"Content-Type\": \"application/json\"},         body)     _log_json_resp(\"Seattle\", url, body, response)     return response"
        ],
        [
            "async def json_or_text(response):     \"\"\"Turns response into a properly formatted json or text object\"\"\"     text = await response.text()     if response.headers['Content-Type'] == 'application/json; charset=utf-8':         return json.loads(text)     return text",
            "def url_read_text(url, verbose=True):     r\"\"\"     Directly reads text data from url     \"\"\"     data = url_read(url, verbose)     text = data.decode('utf8')     return text"
        ]
    ],
    [
        "python how to prase the response json",
        [
            "def get_jsonparsed_data(url):     \"\"\"Receive the content of ``url``, parse it as JSON and return the        object.     \"\"\"     response = urlopen(url)     data = response.read().decode('utf-8')     return json.loads(data)",
            "async def json_or_text(response):     \"\"\"Turns response into a properly formatted json or text object\"\"\"     text = await response.text()     if response.headers['Content-Type'] == 'application/json; charset=utf-8':         return json.loads(text)     return text",
            "def load_data(url): \t\"\"\" \t\"\"\"  \t# http request \tr = requests.get(url)  \t# decode to json \tdata = r.json()  \treturn data",
            "def response_to_json_dict(response, **kwargs):     \"\"\"     Standard place to convert responses to JSON.      :param response: requests response object     :param **kwargs: arguments accepted by json.loads      :returns: dict of JSON response     \"\"\"     if response.encoding is None:         response.encoding = 'utf-8'     return json.loads(response.text, **kwargs)",
            "def post_sea_resource(url, body):     \"\"\"     Get the requested resource using the Seattle account     :returns: http response with content in json     \"\"\"     response = None     response = TrumbaSea_DAO().postURL(         url,         {\"Content-Type\": \"application/json\"},         body)     _log_json_resp(\"Seattle\", url, body, response)     return response"
        ],
        [
            "async def json_or_text(response):     \"\"\"Turns response into a properly formatted json or text object\"\"\"     text = await response.text()     if response.headers['Content-Type'] == 'application/json; charset=utf-8':         return json.loads(text)     return text",
            "def get_jsonparsed_data(url):     \"\"\"Receive the content of ``url``, parse it as JSON and return the        object.     \"\"\"     response = urlopen(url)     data = response.read().decode('utf-8')     return json.loads(data)",
            "def result(self):         \"\"\" Return the result of the AMP (as a string)\"\"\"         ret = self.get('result')         if ret is not None:             ret = u(ret)         return ret",
            "def load_data(url): \t\"\"\" \t\"\"\"  \t# http request \tr = requests.get(url)  \t# decode to json \tdata = r.json()  \treturn data",
            "def print_tree(self, indent=2):         \"\"\" print_tree: prints out structure of tree             Args: indent (int): What level of indentation at which to start printing             Returns: None         \"\"\"         config.LOGGER.info(\"{indent}{data}\".format(indent=\"   \" * indent, data=str(self)))         for child in self.children:             child.print_tree(indent + 1)"
        ],
        [
            "def response_to_json_dict(response, **kwargs):     \"\"\"     Standard place to convert responses to JSON.      :param response: requests response object     :param **kwargs: arguments accepted by json.loads      :returns: dict of JSON response     \"\"\"     if response.encoding is None:         response.encoding = 'utf-8'     return json.loads(response.text, **kwargs)",
            "def prt_js(js, sort_keys=True, indent=4):     \"\"\"Print Json in pretty format.     There's a standard module pprint, can pretty print python dict and list.     But it doesn't support sorted key. That why we need this func.      Usage::          >>> from weatherlab.lib.dataIO.js import prt_js         >>> prt_js({\"a\": 1, \"b\": 2})         {             \"a\": 1,             \"b\": 2         }      **\u4e2d\u6587\u6587\u6863**      \u4ee5\u4eba\u7c7b\u53ef\u8bfb\u7684\u65b9\u5f0f\u6253\u5370\u53efJson\u5316\u7684Python\u5bf9\u8c61\u3002     \"\"\"     print(js2str(js, sort_keys, indent))"
        ]
    ],
    [
        "python loop until and do nothing",
        [
            "def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)",
            "def main():     \"\"\"Ideally we shouldn't lose the first second of events\"\"\"     time.sleep(1)     with Input() as input_generator:         for e in input_generator:             print(repr(e))",
            "def needs_check(self):         \"\"\"         Check if enough time has elapsed to perform a check().          If this time has elapsed, a state change check through         has_state_changed() should be performed and eventually a sync().          :rtype: boolean         \"\"\"         if self.lastcheck is None:             return True         return time.time() - self.lastcheck >= self.ipchangedetection_sleep",
            "def wait_until_exit(self):         \"\"\" Wait until thread exit              Used for testing purpose only         \"\"\"          if self._timeout is None:             raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\")          self._thread.join()         self.stop()",
            "def Join(self):     \"\"\"Waits until all outstanding tasks are completed.\"\"\"      for _ in range(self.JOIN_TIMEOUT_DECISECONDS):       if self._queue.empty() and not self.busy_threads:         return       time.sleep(0.1)      raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)"
        ],
        [
            "def main():     \"\"\"Ideally we shouldn't lose the first second of events\"\"\"     time.sleep(1)     with Input() as input_generator:         for e in input_generator:             print(repr(e))",
            "def seconds(num):     \"\"\"     Pause for this many seconds     \"\"\"     now = pytime.time()     end = now + num     until(end)",
            "def main(idle):     \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"     while True:          LOG.debug(\"Sleeping for {0} seconds.\".format(idle))         time.sleep(idle)",
            "def repeat(f, dt=1/60):     \"\"\" \u91cd\u590d\u6267\u884c\u51fd\u6570f\uff0c\u65f6\u95f4\u95f4\u9694dt \"\"\"     stop(f)     pyglet.clock.schedule_interval(f, dt)",
            "def needs_check(self):         \"\"\"         Check if enough time has elapsed to perform a check().          If this time has elapsed, a state change check through         has_state_changed() should be performed and eventually a sync().          :rtype: boolean         \"\"\"         if self.lastcheck is None:             return True         return time.time() - self.lastcheck >= self.ipchangedetection_sleep"
        ],
        [
            "def stop(self) -> None:         \"\"\"Stops the analysis as soon as possible.\"\"\"         if self._stop and not self._posted_kork:             self._stop()             self._stop = None",
            "def wait_until_exit(self):         \"\"\" Wait until thread exit              Used for testing purpose only         \"\"\"          if self._timeout is None:             raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\")          self._thread.join()         self.stop()"
        ]
    ],
    [
        "python how to tell if an int is base 2",
        [
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False",
            "def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False",
            "def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)",
            "def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False"
        ],
        [
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def is_number(obj):     \"\"\"     Helper function to determine numbers     across Python 2.x and 3.x     \"\"\"     try:         from numbers import Number     except ImportError:         from operator import isNumberType         return isNumberType(obj)     else:         return isinstance(obj, Number)",
            "def try_convert(value):         \"\"\"Convert value to a numeric value or raise a ValueError         if that isn't possible.          \"\"\"         convertible = ForceNumeric.is_convertible(value)         if not convertible or isinstance(value, bool):             raise ValueError         if isinstance(str(value), str):             return ForceNumeric.str_to_num(value)         return float(value)",
            "def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False",
            "def _isint(string):     \"\"\"     >>> _isint(\"123\")     True     >>> _isint(\"123.45\")     False     \"\"\"     return type(string) is int or \\            (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\            _isconvertible(int, string)"
        ],
        [
            "def _find_base_type(data_type):     \"\"\"Find the Nani's base type for a given data type.      This is useful when Nani's data types were subclassed and the original type     is required.     \"\"\"     bases = type(data_type).__mro__     for base in bases:         if base in _ALL:             return base      return None",
            "def _is_bit(obj):     \"\"\"Determine if obj is a bit\"\"\"     # If there is a bit type this could be replaced by isinstance.     if isinstance(obj, tuple) and len(obj) == 2:         if isinstance(obj[0], Register) and isinstance(obj[1], int) and obj[1] < len(obj[0]):             return True     return False"
        ]
    ],
    [
        "python send method as a variable",
        [
            "def notify(self, msgtype, method, params):         \"\"\"Handle an incoming notify request.\"\"\"         self.dispatch.call(method, params)",
            "def shutdown(self):         \"\"\"close socket, immediately.\"\"\"         if self.sock:             self.sock.close()             self.sock = None             self.connected = False",
            "def close(self):         \"\"\"Close the connection.\"\"\"         if self.sock:             self.sock.close()         self.sock = 0         self.eof = 1",
            "async def disconnect(self):         \"\"\" Disconnect from target. \"\"\"         if not self.connected:             return          self.writer.close()         self.reader = None         self.writer = None",
            "def executeMethod(self, methodName, args):     \"\"\"Executes a method named ``methodName`` with the specified arguments.      This method is called when the user executes a command as defined in     the node spec. It provides a perfectly reasonble implementation     of the command mechanism. As a sub-class developer you just need to     implement a method for each command in the node spec. Note that due to     the command mechanism only unnamed argument are supported.      :param methodName: (string) the name of the method that correspond to a            command in the spec.     :param args: (list) of arguments that will be passed to the method     \"\"\"     if not hasattr(self, methodName):       raise Exception('Missing command method: ' + methodName)      m = getattr(self, methodName)     if not hasattr(m, '__call__'):       raise Exception('Command: ' + methodName + ' must be callable')      return m(*args)"
        ],
        [
            "def notify(self, msgtype, method, params):         \"\"\"Handle an incoming notify request.\"\"\"         self.dispatch.call(method, params)",
            "def connected_socket(address, timeout=3):     \"\"\" yields a connected socket \"\"\"     sock = socket.create_connection(address, timeout)     yield sock     sock.close()",
            "def public_broadcaster():     \"\"\"     Thread which runs in parallel and constantly checks for new messages     in the public pipe and broadcasts them publicly to all connected clients.     \"\"\"     while __websocket_server_running__:         pipein = open(PUBLIC_PIPE, 'r')         line = pipein.readline().replace('\\n', '').replace('\\r', '')         if line != '':             WebSocketHandler.broadcast(line)             print line                          remaining_lines = pipein.read()             pipein.close()             pipeout = open(PUBLIC_PIPE, 'w')             pipeout.write(remaining_lines)             pipeout.close()         else:             pipein.close()                  time.sleep(0.05)",
            "def close(self):         \"\"\"Close the connection.\"\"\"         if self.sock:             self.sock.close()         self.sock = 0         self.eof = 1",
            "def shutdown(self):         \"\"\"close socket, immediately.\"\"\"         if self.sock:             self.sock.close()             self.sock = None             self.connected = False"
        ],
        [
            "def _apply_list(self, methods):     \"\"\"Return a single callable that applies a list of methods to a value.      If a method returns None, the last value is kept; if it returns     some other value, that replaces the last value.  Exceptions are     not caught.     \"\"\"     def call(value):       for method in methods:         newvalue = method(self, value)         if newvalue is not None:           value = newvalue       return value     return call",
            "def executeMethod(self, methodName, args):     \"\"\"Executes a method named ``methodName`` with the specified arguments.      This method is called when the user executes a command as defined in     the node spec. It provides a perfectly reasonble implementation     of the command mechanism. As a sub-class developer you just need to     implement a method for each command in the node spec. Note that due to     the command mechanism only unnamed argument are supported.      :param methodName: (string) the name of the method that correspond to a            command in the spec.     :param args: (list) of arguments that will be passed to the method     \"\"\"     if not hasattr(self, methodName):       raise Exception('Missing command method: ' + methodName)      m = getattr(self, methodName)     if not hasattr(m, '__call__'):       raise Exception('Command: ' + methodName + ' must be callable')      return m(*args)"
        ]
    ],
    [
        "extract value from a list of tuples python",
        [
            "def _parse_tuple_string(argument):         \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"         if isinstance(argument, str):             return tuple(int(p.strip()) for p in argument.split(','))         return argument",
            "def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value",
            "def _try_decode_list(content):         \"\"\"Decode content of a list.          :param list|tuple content:         :return:         \"\"\"         result = list()         for value in content:             result.append(try_utf8_decode(value))         return result",
            "def readTuple(self, line, n=3):         \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.         \"\"\"         numbers = [num for num in line.split(' ') if num]         return [float(num) for num in numbers[1:n + 1]]",
            "def split_elements(value):     \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"     items = [v.strip() for v in value.split(',')]     if len(items) == 1:         items = value.split()     return items"
        ],
        [
            "def _parse_tuple_string(argument):         \"\"\" Return a tuple from parsing 'a,b,c,d' -> (a,b,c,d) \"\"\"         if isinstance(argument, str):             return tuple(int(p.strip()) for p in argument.split(','))         return argument",
            "def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value",
            "def _try_decode_list(content):         \"\"\"Decode content of a list.          :param list|tuple content:         :return:         \"\"\"         result = list()         for value in content:             result.append(try_utf8_decode(value))         return result",
            "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:     \"\"\"     Finds the index of an item in list, which satisfies predicate     :param predicateFn: predicate function to run on items of list     :param items: list of tuples     :return: first index for which predicate function returns True     \"\"\"     try:         return next(i for i, v in enumerate(items) if predicateFn(v))     except StopIteration:         return -1",
            "def flatten(l, types=(list, float)):     \"\"\"     Flat nested list of lists into a single list.     \"\"\"     l = [item if isinstance(item, types) else [item] for item in l]     return [item for sublist in l for item in sublist]"
        ],
        [
            "def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))",
            "def readTuple(self, line, n=3):         \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.         \"\"\"         numbers = [num for num in line.split(' ') if num]         return [float(num) for num in numbers[1:n + 1]]"
        ]
    ],
    [
        "python remove last 3 elements from list",
        [
            "def remove(self, item):         \"\"\"Remove the first occurence of an item, the caseless way.\"\"\"         for entry in self:             if item.lower() == entry.lower():                 list.remove(self, entry)                 return         raise ValueError(': list.remove(x): x not in list')",
            "def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l",
            "def _poplast(self):         \"\"\"For avoiding lock during inserting to keep maxlen\"\"\"          try:             tup = self.data.pop()         except IndexError as ex:             ex.args = ('DEPQ is already empty',)             raise          self_items = self.items          try:             self_items[tup[0]] -= 1             if self_items[tup[0]] == 0:                 del self_items[tup[0]]         except TypeError:             r = repr(tup[0])             self_items[r] -= 1             if self_items[r] == 0:                 del self_items[r]          return tup",
            "def tail(self, n=10):         \"\"\"         Get an SArray that contains the last n elements in the SArray.          Parameters         ----------         n : int             The number of elements to fetch          Returns         -------         out : SArray             A new SArray which contains the last n rows of the current SArray.         \"\"\"         with cython_context():             return SArray(_proxy=self.__proxy__.tail(n))",
            "def indicate_last(items):     \"\"\"     iterate through list and indicate which item is the last, intended to     assist tree displays of hierarchical content.      :return: yielding (<bool>, <item>) where bool is True only on last entry     :rtype: generator     \"\"\"     last_index = len(items) - 1     for (i, item) in enumerate(items):         yield (i == last_index, item)"
        ],
        [
            "def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l",
            "def remove(self, item):         \"\"\"Remove the first occurence of an item, the caseless way.\"\"\"         for entry in self:             if item.lower() == entry.lower():                 list.remove(self, entry)                 return         raise ValueError(': list.remove(x): x not in list')",
            "def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]",
            "def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique",
            "def remove_list_duplicates(lista, unique=False):     \"\"\"     Remove duplicated elements in a list.     Args:         lista: List with elements to clean duplicates.     \"\"\"     result = []     allready = []      for elem in lista:         if elem not in result:             result.append(elem)         else:             allready.append(elem)      if unique:         for elem in allready:             result = list(filter((elem).__ne__, result))      return result"
        ],
        [
            "def indicate_last(items):     \"\"\"     iterate through list and indicate which item is the last, intended to     assist tree displays of hierarchical content.      :return: yielding (<bool>, <item>) where bool is True only on last entry     :rtype: generator     \"\"\"     last_index = len(items) - 1     for (i, item) in enumerate(items):         yield (i == last_index, item)",
            "def get_last(self, table=None):         \"\"\"Just the last entry.\"\"\"         if table is None: table = self.main_table         query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table         return self.own_cursor.execute(query).fetchone()"
        ]
    ],
    [
        "is 0 not an integer in python",
        [
            "def IntGreaterThanZero(n):     \"\"\"If *n* is an integer > 0, returns it, otherwise an error.\"\"\"     try:         n = int(n)     except:         raise ValueError(\"%s is not an integer\" % n)     if n <= 0:         raise ValueError(\"%d is not > 0\" % n)     else:         return n",
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False",
            "def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))",
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False"
        ],
        [
            "def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))",
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def try_convert(value):         \"\"\"Convert value to a numeric value or raise a ValueError         if that isn't possible.          \"\"\"         convertible = ForceNumeric.is_convertible(value)         if not convertible or isinstance(value, bool):             raise ValueError         if isinstance(str(value), str):             return ForceNumeric.str_to_num(value)         return float(value)",
            "def _tofloat(obj):     \"\"\"Convert to float if object is a float string.\"\"\"     if \"inf\" in obj.lower().strip():         return obj     try:         return int(obj)     except ValueError:         try:             return float(obj)         except ValueError:             return obj",
            "def str2int(num, radix=10, alphabet=BASE85):     \"\"\"helper function for quick base conversions from strings to integers\"\"\"     return NumConv(radix, alphabet).str2int(num)"
        ],
        [
            "def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False",
            "def to_int(self):         \"\"\"Convert vector to an integer, if possible.          This is only useful for arrays filled with zero/one entries.         \"\"\"         num = self.to_uint()         if num and self._items[-1].unbox():             return num - (1 << self.size)         else:             return num"
        ]
    ],
    [
        "remove whitespace in a list in python",
        [
            "def clean_strings(iterable):     \"\"\"     Take a list of strings and clear whitespace      on each one. If a value in the list is not a      string pass it through untouched.      Args:         iterable: mixed list      Returns:          mixed list     \"\"\"     retval = []     for val in iterable:         try:             retval.append(val.strip())         except(AttributeError):             retval.append(val)     return retval",
            "def remove_bad(string):     \"\"\"     remove problem characters from string     \"\"\"     remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']     for c in remove:         string = string.replace(c, '_')     return string",
            "def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))",
            "def strip_spaces(value, sep=None, join=True):     \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"     value = value.strip()     value = [v.strip() for v in value.split(sep)]     join_sep = sep or ' '     return join_sep.join(value) if join else value",
            "def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])"
        ],
        [
            "def clean(self, text):         \"\"\"Remove all unwanted characters from text.\"\"\"         return ''.join([c for c in text if c in self.alphabet])",
            "def remove_bad(string):     \"\"\"     remove problem characters from string     \"\"\"     remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']     for c in remove:         string = string.replace(c, '_')     return string",
            "def unpunctuate(s, *, char_blacklist=string.punctuation):     \"\"\" Remove punctuation from string s. \"\"\"     # remove punctuation     s = \"\".join(c for c in s if c not in char_blacklist)     # remove consecutive spaces     return \" \".join(filter(None, s.split(\" \")))",
            "def strip_spaces(s):     \"\"\" Strip excess spaces from a string \"\"\"     return u\" \".join([c for c in s.split(u' ') if c])",
            "def drop_bad_characters(text):     \"\"\"Takes a text and drops all non-printable and non-ascii characters and     also any whitespace characters that aren't space.      :arg str text: the text to fix      :returns: text with all bad characters dropped      \"\"\"     # Strip all non-ascii and non-printable characters     text = ''.join([c for c in text if c in ALLOWED_CHARS])     return text"
        ],
        [
            "def _str_to_list(s):     \"\"\"Converts a comma separated string to a list\"\"\"     _list = s.split(\",\")     return list(map(lambda i: i.lstrip(), _list))",
            "def strip_spaces(value, sep=None, join=True):     \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"     value = value.strip()     value = [v.strip() for v in value.split(sep)]     join_sep = sep or ' '     return join_sep.join(value) if join else value"
        ]
    ],
    [
        "check if an element exist python",
        [
            "def is_present(self, selector):         \"\"\"Check if an element is present in the dom or not          This method won't check if the element is displayed or not         This method won't wait until the element is visible or present         This method won't raise any exception if the element is not present          Returns:             bool: True if the element is present; False otherwise         \"\"\"         self.debug_log(\"Is present (%s)\" % selector)          element = self.find(             selector,             raise_exception=False,             wait_until_present=False,             wait_until_visible=False         )         if element:             self.debug_log(\"is present: True\")             return True         else:             self.debug_log(\"is present: False\")             return False",
            "def elXpath(self, xpath, dom=None):         \"\"\"check if element is present by css\"\"\"         if dom is None:             dom = self.browser         return expect(dom.is_element_present_by_xpath, args=[xpath])",
            "def selected(self):         \"\"\"         Check whether all the matched elements are selected.          Returns:             bool         \"\"\"         query_results = self.map(lambda el: el.is_selected(), 'selected').results         if query_results:             return all(query_results)         return False",
            "def is_break_tag(self, el):         \"\"\"Check if tag is an element we should break on.\"\"\"          name = el.name         return name in self.break_tags or name in self.user_break_tags",
            "def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found"
        ],
        [
            "def isin(value, values):     \"\"\" Check that value is in values \"\"\"     for i, v in enumerate(value):         if v not in np.array(values)[:, i]:             return False     return True",
            "def _not_none(items):     \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"     if not isinstance(items, (tuple, list)):         items = (items,)     return all(item is not _none for item in items)",
            "def isin(elems, line):     \"\"\"Check if an element from a list is in a string.      :type elems: list     :type line: str      \"\"\"     found = False     for e in elems:         if e in line.lower():             found = True             break     return found",
            "def isreal(obj):     \"\"\"     Test if the argument is a real number (float or integer).      :param obj: Object     :type  obj: any      :rtype: boolean     \"\"\"     return (         (obj is not None)         and (not isinstance(obj, bool))         and isinstance(obj, (int, float))     )",
            "def is_identifier(string):     \"\"\"Check if string could be a valid python identifier      :param string: string to be tested     :returns: True if string can be a python identifier, False otherwise     :rtype: bool     \"\"\"     matched = PYTHON_IDENTIFIER_RE.match(string)     return bool(matched) and not keyword.iskeyword(string)"
        ],
        [
            "def elXpath(self, xpath, dom=None):         \"\"\"check if element is present by css\"\"\"         if dom is None:             dom = self.browser         return expect(dom.is_element_present_by_xpath, args=[xpath])",
            "def is_present(self, selector):         \"\"\"Check if an element is present in the dom or not          This method won't check if the element is displayed or not         This method won't wait until the element is visible or present         This method won't raise any exception if the element is not present          Returns:             bool: True if the element is present; False otherwise         \"\"\"         self.debug_log(\"Is present (%s)\" % selector)          element = self.find(             selector,             raise_exception=False,             wait_until_present=False,             wait_until_visible=False         )         if element:             self.debug_log(\"is present: True\")             return True         else:             self.debug_log(\"is present: False\")             return False"
        ]
    ],
    [
        "sort uniq in python strings",
        [
            "def natural_sort(list_to_sort: Iterable[str]) -> List[str]:     \"\"\"     Sorts a list of strings case insensitively as well as numerically.      For example: ['a1', 'A2', 'a3', 'A11', 'a22']      To sort a list in place, don't call this method, which makes a copy. Instead, do this:      my_list.sort(key=natural_keys)      :param list_to_sort: the list being sorted     :return: the list sorted naturally     \"\"\"     return sorted(list_to_sort, key=natural_keys)",
            "def transcript_sort_key(transcript):     \"\"\"     Key function used to sort transcripts. Taking the negative of     protein sequence length and nucleotide sequence length so that     the transcripts with longest sequences come first in the list. This couldn't     be accomplished with `reverse=True` since we're also sorting by     transcript name (which places TP53-001 before TP53-002).     \"\"\"     return (         -len(transcript.protein_sequence),         -len(transcript.sequence),         transcript.name     )",
            "def get_order(self, codes):         \"\"\"Return evidence codes in order shown in code2name.\"\"\"         return sorted(codes, key=lambda e: [self.ev2idx.get(e)])",
            "def uniqued(iterable):     \"\"\"Return unique list of ``iterable`` items preserving order.      >>> uniqued('spameggs')     ['s', 'p', 'a', 'm', 'e', 'g']     \"\"\"     seen = set()     return [item for item in iterable if item not in seen and not seen.add(item)]",
            "def csort(objs, key):     \"\"\"Order-preserving sorting function.\"\"\"     idxs = dict((obj, i) for (i, obj) in enumerate(objs))     return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))"
        ],
        [
            "def natural_sort(list_to_sort: Iterable[str]) -> List[str]:     \"\"\"     Sorts a list of strings case insensitively as well as numerically.      For example: ['a1', 'A2', 'a3', 'A11', 'a22']      To sort a list in place, don't call this method, which makes a copy. Instead, do this:      my_list.sort(key=natural_keys)      :param list_to_sort: the list being sorted     :return: the list sorted naturally     \"\"\"     return sorted(list_to_sort, key=natural_keys)",
            "def get_order(self, codes):         \"\"\"Return evidence codes in order shown in code2name.\"\"\"         return sorted(codes, key=lambda e: [self.ev2idx.get(e)])",
            "def csort(objs, key):     \"\"\"Order-preserving sorting function.\"\"\"     idxs = dict((obj, i) for (i, obj) in enumerate(objs))     return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))",
            "def transcript_sort_key(transcript):     \"\"\"     Key function used to sort transcripts. Taking the negative of     protein sequence length and nucleotide sequence length so that     the transcripts with longest sequences come first in the list. This couldn't     be accomplished with `reverse=True` since we're also sorting by     transcript name (which places TP53-001 before TP53-002).     \"\"\"     return (         -len(transcript.protein_sequence),         -len(transcript.sequence),         transcript.name     )",
            "def toposort_flatten(data, sort=True):     \"\"\"Returns a single list of dependencies. For any set returned by toposort(), those items are sorted and appended to the result (just to make the results deterministic).\"\"\"      result = []     for d in toposort(data):         try:             result.extend((sorted if sort else list)(d))         except TypeError as e:             result.extend(list(d))     return result"
        ],
        [
            "def uniqued(iterable):     \"\"\"Return unique list of ``iterable`` items preserving order.      >>> uniqued('spameggs')     ['s', 'p', 'a', 'm', 'e', 'g']     \"\"\"     seen = set()     return [item for item in iterable if item not in seen and not seen.add(item)]",
            "def _uniquify(_list):     \"\"\"Remove duplicates in a list.\"\"\"     seen = set()     result = []     for x in _list:         if x not in seen:             result.append(x)             seen.add(x)     return result"
        ]
    ],
    [
        "first item in a tuple python",
        [
            "def pairwise(iterable):     \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"     first, second = tee(iterable)     next(second, None)     return zip(first, second)",
            "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:     \"\"\"     Finds the index of an item in list, which satisfies predicate     :param predicateFn: predicate function to run on items of list     :param items: list of tuples     :return: first index for which predicate function returns True     \"\"\"     try:         return next(i for i, v in enumerate(items) if predicateFn(v))     except StopIteration:         return -1",
            "def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value",
            "def ziptake(items_list, indexes_list):     \"\"\"     SeeAlso:         vt.ziptake     \"\"\"     return [take(list_, index_list)             for list_, index_list in zip(items_list, indexes_list)]",
            "def iget_list_column_slice(list_, start=None, stop=None, stride=None):     \"\"\" iterator version of get_list_column \"\"\"     if isinstance(start, slice):         slice_ = start     else:         slice_ = slice(start, stop, stride)     return (row[slice_] for row in list_)"
        ],
        [
            "def pairwise(iterable):     \"\"\"From itertools cookbook. [a, b, c, ...] -> (a, b), (b, c), ...\"\"\"     first, second = tee(iterable)     next(second, None)     return zip(first, second)",
            "def getIndex(predicateFn: Callable[[T], bool], items: List[T]) -> int:     \"\"\"     Finds the index of an item in list, which satisfies predicate     :param predicateFn: predicate function to run on items of list     :param items: list of tuples     :return: first index for which predicate function returns True     \"\"\"     try:         return next(i for i, v in enumerate(items) if predicateFn(v))     except StopIteration:         return -1",
            "def iter_items(iterable):     \"\"\" Iterate through all items (key-value pairs) within an iterable     dictionary-like object. If the object has a `keys` method, this is     used along with `__getitem__` to yield each pair in turn. If no     `keys` method exists, each iterable element is assumed to be a     2-tuple of key and value.     \"\"\"     if hasattr(iterable, \"keys\"):         for key in iterable.keys():             yield key, iterable[key]     else:         for key, value in iterable:             yield key, value",
            "def iget_list_column_slice(list_, start=None, stop=None, stride=None):     \"\"\" iterator version of get_list_column \"\"\"     if isinstance(start, slice):         slice_ = start     else:         slice_ = slice(start, stop, stride)     return (row[slice_] for row in list_)",
            "def ziptake(items_list, indexes_list):     \"\"\"     SeeAlso:         vt.ziptake     \"\"\"     return [take(list_, index_list)             for list_, index_list in zip(items_list, indexes_list)]"
        ],
        [
            "def as_tuple(self, value):         \"\"\"Utility function which converts lists to tuples.\"\"\"         if isinstance(value, list):             value = tuple(value)         return value",
            "def compose_all(tups):   \"\"\"Compose all given tuples together.\"\"\"   from . import ast  # I weep for humanity   return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))"
        ]
    ],
    [
        "plot points in image python matlibplot",
        [
            "def horizontal_line(ax, scale, i, **kwargs):     \"\"\"     Draws the i-th horizontal line parallel to the lower axis.      Parameters     ----------     ax: Matplotlib AxesSubplot         The subplot to draw on.     scale: float, 1.0         Simplex scale size.     i: float         The index of the line to draw     kwargs: Dictionary         Any kwargs to pass through to Matplotlib.     \"\"\"      p1 = (0, i, scale - i)     p2 = (scale - i, i, 0)     line(ax, p1, p2, **kwargs)",
            "def imshow(self, canvas, X, extent=None, label=None, vmin=None, vmax=None, **kwargs):         \"\"\"         Show the image stored in X on the canvas.                  The origin of the image show is (0,0), such that X[0,0] gets plotted at [0,0] of the image!                  the kwargs are plotting library specific kwargs!         \"\"\"         raise NotImplementedError(\"Implement all plot functions in AbstractPlottingLibrary in order to use your own plotting library\")",
            "def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)",
            "def basic():     \"\"\"Set up a basic stereonet and plot the same data each time.\"\"\"     fig, ax = mplstereonet.subplots()      strike, dip = 315, 30     ax.plane(strike, dip, color='lightblue')     ax.pole(strike, dip, color='green', markersize=15)     ax.rake(strike, dip, 40, marker='*', markersize=20, color='green')      # Make a bit of room for the title...     fig.subplots_adjust(top=0.8)      return ax",
            "def draw_circle(self, color, world_loc, world_radius, thickness=0):     \"\"\"Draw a circle using world coordinates and radius.\"\"\"     if world_radius > 0:       center = self.world_to_surf.fwd_pt(world_loc).round()       radius = max(1, int(self.world_to_surf.fwd_dist(world_radius)))       pygame.draw.circle(self.surf, color, center, radius,                          thickness if thickness < radius else 0)"
        ],
        [
            "def plot_target(target, ax):     \"\"\"Ajoute la target au plot\"\"\"     ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)",
            "def _linepoint(self, t, x0, y0, x1, y1):         \"\"\" Returns coordinates for point at t on the line.             Calculates the coordinates of x and y for a point at t on a straight line.             The t parameter is a number between 0.0 and 1.0,             x0 and y0 define the starting point of the line,             x1 and y1 the ending point of the line.         \"\"\"         # Originally from nodebox-gl         out_x = x0 + t * (x1 - x0)         out_y = y0 + t * (y1 - y0)         return (out_x, out_y)",
            "def horizontal_line(ax, scale, i, **kwargs):     \"\"\"     Draws the i-th horizontal line parallel to the lower axis.      Parameters     ----------     ax: Matplotlib AxesSubplot         The subplot to draw on.     scale: float, 1.0         Simplex scale size.     i: float         The index of the line to draw     kwargs: Dictionary         Any kwargs to pass through to Matplotlib.     \"\"\"      p1 = (0, i, scale - i)     p2 = (scale - i, i, 0)     line(ax, p1, p2, **kwargs)",
            "def finish_plot():     \"\"\"Helper for plotting.\"\"\"     plt.legend()     plt.grid(color='0.7')     plt.xlabel('x')     plt.ylabel('y')     plt.show()",
            "def show_correlation_matrix(self, correlation_matrix):         \"\"\"Shows the given correlation matrix as image          :param correlation_matrix: Correlation matrix of features         \"\"\"         cr_plot.create_correlation_matrix_plot(             correlation_matrix, self.title, self.headers_to_test         )         pyplot.show()"
        ],
        [
            "def draw_image(self, ax, image):         \"\"\"Process a matplotlib image object and call renderer.draw_image\"\"\"         self.renderer.draw_image(imdata=utils.image_to_base64(image),                                  extent=image.get_extent(),                                  coordinates=\"data\",                                  style={\"alpha\": image.get_alpha(),                                         \"zorder\": image.get_zorder()},                                  mplobj=image)",
            "def imshow(self, canvas, X, extent=None, label=None, vmin=None, vmax=None, **kwargs):         \"\"\"         Show the image stored in X on the canvas.                  The origin of the image show is (0,0), such that X[0,0] gets plotted at [0,0] of the image!                  the kwargs are plotting library specific kwargs!         \"\"\"         raise NotImplementedError(\"Implement all plot functions in AbstractPlottingLibrary in order to use your own plotting library\")"
        ]
    ],
    [
        "python input function two integers",
        [
            "def frange(start, stop, step, precision):     \"\"\"A generator that will generate a range of floats.\"\"\"     value = start     while round(value, precision) < stop:         yield round(value, precision)         value += step",
            "def log_gen() -> Iterator[int]:     \"\"\"Logarithmic generator.     \"\"\"     y = 1     while True:         adder = max(1, math.pow(10, int(math.log10(y))))         yield int(y)         y = y + int(adder)",
            "def Counter64(a, b, delta):     \"\"\"64bit counter aggregator with wrapping     \"\"\"     if b < a:         c = 18446744073709551615 - a         return (c + b) / float(delta)      return (b - a) / float(delta)",
            "def IntGreaterThanZero(n):     \"\"\"If *n* is an integer > 0, returns it, otherwise an error.\"\"\"     try:         n = int(n)     except:         raise ValueError(\"%s is not an integer\" % n)     if n <= 0:         raise ValueError(\"%d is not > 0\" % n)     else:         return n",
            "def divide(x: LispNumber, y: LispNumber) -> LispNumber:     \"\"\"Division reducer. If both arguments are integers, return a Fraction.     Otherwise, return the true division of x and y.\"\"\"     if isinstance(x, int) and isinstance(y, int):         return Fraction(x, y)     return x / y"
        ],
        [
            "def log_gen() -> Iterator[int]:     \"\"\"Logarithmic generator.     \"\"\"     y = 1     while True:         adder = max(1, math.pow(10, int(math.log10(y))))         yield int(y)         y = y + int(adder)",
            "def safe_int_conv(number):     \"\"\"Safely convert a single number to integer.\"\"\"     try:         return int(np.array(number).astype(int, casting='safe'))     except TypeError:         raise ValueError('cannot safely convert {} to integer'.format(number))",
            "def isInt(num):     \"\"\"Returns true if `num` is (sort of) an integer.     >>> isInt(3) == isInt(3.0) == 1     True     >>> isInt(3.2)     False     >>> import numpy     >>> isInt(numpy.array(1))     True     >>> isInt(numpy.array([1]))     False     \"\"\"     try:         len(num) # FIXME fails for Numeric but Numeric is obsolete     except:         try:             return (num - math.floor(num) == 0) == True         except: return False     else: return False",
            "def valuesToInts(values):     \"\"\"     Iterable of values to ints (nonvalid = None)     \"\"\"     res = []     append = res.append     for d in values:         if isinstance(d, int):             append(d)         else:             append(valToInt(d))     return res",
            "def _numbers_units(N):     \"\"\"     >>> _numbers_units(45)     '123456789012345678901234567890123456789012345'     \"\"\"     lst = range(1, N + 1)     return \"\".join(list(map(lambda i: str(i % 10), lst)))"
        ],
        [
            "def minus(*args):     \"\"\"Also, converts either to ints or to floats.\"\"\"     if len(args) == 1:         return -to_numeric(args[0])     return to_numeric(args[0]) - to_numeric(args[1])",
            "def divide(x: LispNumber, y: LispNumber) -> LispNumber:     \"\"\"Division reducer. If both arguments are integers, return a Fraction.     Otherwise, return the true division of x and y.\"\"\"     if isinstance(x, int) and isinstance(y, int):         return Fraction(x, y)     return x / y"
        ]
    ],
    [
        "how to add dollar signs to in python",
        [
            "def convert(self, value, units, newunits):         \"\"\"         Converts a value expressed in certain *units* to a new units.         \"\"\"         return value * self._units[units] / self._units[newunits]",
            "def divide(x: LispNumber, y: LispNumber) -> LispNumber:     \"\"\"Division reducer. If both arguments are integers, return a Fraction.     Otherwise, return the true division of x and y.\"\"\"     if isinstance(x, int) and isinstance(y, int):         return Fraction(x, y)     return x / y",
            "def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string",
            "def round_to_x_digits(number, digits):     \"\"\"     Returns 'number' rounded to 'digits' digits.     \"\"\"     return round(number * math.pow(10, digits)) / math.pow(10, digits)",
            "def round_to_int(number, precision):     \"\"\"Round a number to a precision\"\"\"     precision = int(precision)     rounded = (int(number) + precision / 2) // precision * precision     return rounded"
        ],
        [
            "def convert(self, value, units, newunits):         \"\"\"         Converts a value expressed in certain *units* to a new units.         \"\"\"         return value * self._units[units] / self._units[newunits]",
            "def round_to_x_digits(number, digits):     \"\"\"     Returns 'number' rounded to 'digits' digits.     \"\"\"     return round(number * math.pow(10, digits)) / math.pow(10, digits)",
            "def py3round(number):     \"\"\"Unified rounding in all python versions.\"\"\"     if abs(round(number) - number) == 0.5:         return int(2.0 * round(number / 2.0))      return int(round(number))",
            "def round_float(f, digits, rounding=ROUND_HALF_UP):     \"\"\"     Accurate float rounding from http://stackoverflow.com/a/15398691.     \"\"\"     return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits),                                     rounding=rounding)",
            "def round_to_int(number, precision):     \"\"\"Round a number to a precision\"\"\"     precision = int(precision)     rounded = (int(number) + precision / 2) // precision * precision     return rounded"
        ],
        [
            "def format_screen(strng):     \"\"\"Format a string for screen printing.      This removes some latex-type format codes.\"\"\"     # Paragraph continue     par_re = re.compile(r'\\\\$',re.MULTILINE)     strng = par_re.sub('',strng)     return strng",
            "def format_float(value): # not used     \"\"\"Modified form of the 'g' format specifier.     \"\"\"     string = \"{:g}\".format(value).replace(\"e+\", \"e\")     string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)     return string"
        ]
    ],
    [
        "python remove redundant elements of list",
        [
            "def remove_list_duplicates(lista, unique=False):     \"\"\"     Remove duplicated elements in a list.     Args:         lista: List with elements to clean duplicates.     \"\"\"     result = []     allready = []      for elem in lista:         if elem not in result:             result.append(elem)         else:             allready.append(elem)      if unique:         for elem in allready:             result = list(filter((elem).__ne__, result))      return result",
            "def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]",
            "def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]",
            "def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique",
            "def remove(self, item):         \"\"\"Remove the first occurence of an item, the caseless way.\"\"\"         for entry in self:             if item.lower() == entry.lower():                 list.remove(self, entry)                 return         raise ValueError(': list.remove(x): x not in list')"
        ],
        [
            "def remove_list_duplicates(lista, unique=False):     \"\"\"     Remove duplicated elements in a list.     Args:         lista: List with elements to clean duplicates.     \"\"\"     result = []     allready = []      for elem in lista:         if elem not in result:             result.append(elem)         else:             allready.append(elem)      if unique:         for elem in allready:             result = list(filter((elem).__ne__, result))      return result",
            "def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]",
            "def remove_duplicates(lst):     \"\"\"     Emulate what a Python ``set()`` does, but keeping the element's order.     \"\"\"     dset = set()     return [l for l in lst if l not in dset and not dset.add(l)]",
            "def dedupe_list(l):     \"\"\"Remove duplicates from a list preserving the order.      We might be tempted to use the list(set(l)) idiom, but it doesn't preserve     the order, which hinders testability and does not work for lists with     unhashable elements.     \"\"\"     result = []      for el in l:         if el not in result:             result.append(el)      return result",
            "def remove(self, item):         \"\"\"Remove the first occurence of an item, the caseless way.\"\"\"         for entry in self:             if item.lower() == entry.lower():                 list.remove(self, entry)                 return         raise ValueError(': list.remove(x): x not in list')"
        ],
        [
            "def dedup_list(l):     \"\"\"Given a list (l) will removing duplicates from the list,        preserving the original order of the list. Assumes that        the list entrie are hashable.\"\"\"     dedup = set()     return [ x for x in l if not (x in dedup or dedup.add(x))]",
            "def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique"
        ]
    ],
    [
        "python, how to put a variable in a string",
        [
            "def safe_format(s, **kwargs):   \"\"\"   :type s str   \"\"\"   return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))",
            "def add_colons(s):     \"\"\"Add colons after every second digit.      This function is used in functions to prettify serials.      >>> add_colons('teststring')     'te:st:st:ri:ng'     \"\"\"     return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])",
            "def __str__(self): \t\t\"\"\" Convert to string  \t\t:return: str \t\t\"\"\" \t\taddress = [\"{:02x}\".format(int(x)) for x in self.__address] \t\treturn ':'.join(address)",
            "def __str__(self):         \"\"\"Returns full address string.\"\"\"         return \"{}\\n{}, {} {}\".format(self.street, self.city, self.state, self.postal_code)",
            "def concat_padded(base, *args):     \"\"\"     Concatenate string and zero-padded 4 digit number     \"\"\"     ret = base     for n in args:         if is_string(n):             ret = \"%s_%s\" % (ret, n)         else:             ret = \"%s_%04i\"  % (ret, n + 1)     return ret"
        ],
        [
            "def _escape(self, s):         \"\"\"Escape bad characters for regular expressions.          Similar to `re.escape` but allows '%' to pass through.          \"\"\"         for ch, r_ch in self.ESCAPE_SETS:             s = s.replace(ch, r_ch)         return s",
            "def do_forceescape(value):     \"\"\"Enforce HTML escaping.  This will probably double escape variables.\"\"\"     if hasattr(value, '__html__'):         value = value.__html__()     return escape(text_type(value))",
            "def _vars_match(self):         \"\"\"Regular expression to match playbook variable.\"\"\"         return re.compile(             r'#([A-Za-z]+)'  # match literal (#App) at beginning of String             r':([\\d]+)'  # app id (:7979)             r':([A-Za-z0-9_\\.\\-\\[\\]]+)'  # variable name (:variable_name)             r'!(StringArray|BinaryArray|KeyValueArray'  # variable type (array)             r'|TCEntityArray|TCEnhancedEntityArray'  # variable type (array)             r'|String|Binary|KeyValue|TCEntity|TCEnhancedEntity'  # variable type             r'|(?:(?!String)(?!Binary)(?!KeyValue)'  # non matching for custom             r'(?!TCEntity)(?!TCEnhancedEntity)'  # non matching for custom             r'[A-Za-z0-9_-]+))'  # variable type (custom)         )",
            "def string_format_func(s): \t\"\"\" \tFunction used internally to format string data for output to XML. \tEscapes back-slashes and quotes, and wraps the resulting string in \tquotes. \t\"\"\" \treturn u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")",
            "def format_name(text):     \"\"\"Format a comic name.\"\"\"     name = unescape(text)     name = asciify(name.replace(u'&', u'And').replace(u'@', u'At'))     name = capfirst(name)     return name"
        ],
        [
            "def __str__(self):         \"\"\"Returns full address string.\"\"\"         return \"{}\\n{}, {} {}\".format(self.street, self.city, self.state, self.postal_code)",
            "def full_name(self):         \"\"\"         You can get full name of user.          :return: str         \"\"\"         full_name = self.first_name         if self.last_name:             full_name += ' ' + self.last_name         return full_name"
        ]
    ],
    [
        "python string replace dash",
        [
            "def dashrepl(value):     \"\"\"     Replace any non-word characters with a dash.     \"\"\"     patt = re.compile(r'\\W', re.UNICODE)     return re.sub(patt, '-', value)",
            "def insert_slash(string, every=2):     \"\"\"insert_slash insert / every 2 char\"\"\"     return os.path.join(string[i:i+every] for i in xrange(0, len(string), every))",
            "def remove_bad(string):     \"\"\"     remove problem characters from string     \"\"\"     remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']     for c in remove:         string = string.replace(c, '_')     return string",
            "def slugify(value):     \"\"\"Simple Slugify.\"\"\"     s1 = first_cap_re.sub(r'\\1_\\2', value)     s2 = all_cap_re.sub(r'\\1_\\2', s1)     return s2.lower().replace(' _', '_').replace(' ', '_')",
            "def _escape(self, s):         \"\"\"Escape bad characters for regular expressions.          Similar to `re.escape` but allows '%' to pass through.          \"\"\"         for ch, r_ch in self.ESCAPE_SETS:             s = s.replace(ch, r_ch)         return s"
        ],
        [
            "def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s",
            "def dashrepl(value):     \"\"\"     Replace any non-word characters with a dash.     \"\"\"     patt = re.compile(r'\\W', re.UNICODE)     return re.sub(patt, '-', value)",
            "def _remove_invalid_char(s):     \"\"\"Remove invalid and dangerous characters from a string.\"\"\"      s = ''.join([i if ord(i) >= 32 and ord(i) < 127 else '' for i in s])     s = s.translate(dict.fromkeys(map(ord, \"_%~#\\\\{}\\\":\")))     return s",
            "def remove_bad(string):     \"\"\"     remove problem characters from string     \"\"\"     remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']     for c in remove:         string = string.replace(c, '_')     return string",
            "def strip_non_ascii(s):     \"\"\"     Returns the string without non-ASCII characters.      Parameters     ----------     string : string         A string that may contain non-ASCII characters.      Returns     -------     clean_string : string         A string that does not contain non-ASCII characters.      \"\"\"     stripped = (c for c in s if 0 < ord(c) < 127)     clean_string = u''.join(stripped)     return clean_string"
        ],
        [
            "def slugify(value):     \"\"\"Simple Slugify.\"\"\"     s1 = first_cap_re.sub(r'\\1_\\2', value)     s2 = all_cap_re.sub(r'\\1_\\2', s1)     return s2.lower().replace(' _', '_').replace(' ', '_')",
            "def slugify(s):     \"\"\"     Converts the given string to a URL slug.     \"\"\"     s = strip_accents(s.replace(\"'\", '').lower())     return re.sub('[^a-z0-9]+', ' ', s).strip().replace(' ', '-')"
        ]
    ],
    [
        "display result without matrix wrapper python",
        [
            "def Tmatrix(X):     \"\"\"     gets the orientation matrix (T) from data in X     \"\"\"     T = [[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]     for row in X:         for k in range(3):             for l in range(3):                 T[k][l] += row[k] * row[l]     return T",
            "def get_matrix(self):         \"\"\"  Use numpy to create a real matrix object from the data          :return: the matrix representation of the fvm         \"\"\"         return np.array([ self.get_row_list(i) for i in range(self.row_count()) ])",
            "def print_matrix(X, decimals=1):     \"\"\"Pretty printing for numpy matrix X\"\"\"     for row in np.round(X, decimals=decimals):         print(row)",
            "def rotate_2D(angle):     \"\"\"     Returns a 2x2 transformation matrix to rotate     by an angle in two dimensions     \"\"\"     return N.array([[N.cos(angle),-N.sin(angle)],                     [N.sin(angle),N.cos(angle)]])",
            "def Ry_matrix(theta):     \"\"\"Rotation matrix around the Y axis\"\"\"     return np.array([         [np.cos(theta), 0, np.sin(theta)],         [0, 1, 0],         [-np.sin(theta), 0, np.cos(theta)]     ])"
        ],
        [
            "def im2mat(I):     \"\"\"Converts and image to matrix (one pixel per line)\"\"\"     return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))",
            "def get_matrix(self):         \"\"\"  Use numpy to create a real matrix object from the data          :return: the matrix representation of the fvm         \"\"\"         return np.array([ self.get_row_list(i) for i in range(self.row_count()) ])",
            "def transform(foci, mat):     \"\"\" Convert coordinates from one space to another using provided     transformation matrix. \"\"\"     t = linalg.pinv(mat)     foci = np.hstack((foci, np.ones((foci.shape[0], 1))))     return np.dot(foci, t)[:, 0:3]",
            "def hflip(img):     \"\"\"Horizontally flip the given PIL Image.      Args:         img (PIL Image): Image to be flipped.      Returns:         PIL Image:  Horizontall flipped image.     \"\"\"     if not _is_pil_image(img):         raise TypeError('img should be PIL Image. Got {}'.format(type(img)))      return img.transpose(Image.FLIP_LEFT_RIGHT)",
            "def extract(self):         \"\"\"         Creates a copy of this tabarray in the form of a numpy ndarray.          Useful if you want to do math on array elements, e.g. if you have a          subset of the columns that are all numerical, you can construct a          numerical matrix and do matrix operations.          \"\"\"         return np.vstack([self[r] for r in self.dtype.names]).T.squeeze()"
        ],
        [
            "def print_matrix(X, decimals=1):     \"\"\"Pretty printing for numpy matrix X\"\"\"     for row in np.round(X, decimals=decimals):         print(row)",
            "def size(self):         \"\"\"Total number of grid points.\"\"\"         # Since np.prod(()) == 1.0 we need to handle that by ourselves         return (0 if self.shape == () else                 int(np.prod(self.shape, dtype='int64')))"
        ]
    ],
    [
        "replace list element in python",
        [
            "def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l",
            "def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s",
            "def remove(self, item):         \"\"\"Remove the first occurence of an item, the caseless way.\"\"\"         for entry in self:             if item.lower() == entry.lower():                 list.remove(self, entry)                 return         raise ValueError(': list.remove(x): x not in list')",
            "def myreplace(astr, thefind, thereplace):     \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"     alist = astr.split(thefind)     new_s = alist.split(thereplace)     return new_s",
            "def remove_list_duplicates(lista, unique=False):     \"\"\"     Remove duplicated elements in a list.     Args:         lista: List with elements to clean duplicates.     \"\"\"     result = []     allready = []      for elem in lista:         if elem not in result:             result.append(elem)         else:             allready.append(elem)      if unique:         for elem in allready:             result = list(filter((elem).__ne__, result))      return result"
        ],
        [
            "def list_move_to_front(l,value='other'):     \"\"\"if the value is in the list, move it to the front and return it.\"\"\"     l=list(l)     if value in l:         l.remove(value)         l.insert(0,value)     return l",
            "def remove_dups(seq):     \"\"\"remove duplicates from a sequence, preserving order\"\"\"     seen = set()     seen_add = seen.add     return [x for x in seq if not (x in seen or seen_add(x))]",
            "def remove_list_duplicates(lista, unique=False):     \"\"\"     Remove duplicated elements in a list.     Args:         lista: List with elements to clean duplicates.     \"\"\"     result = []     allready = []      for elem in lista:         if elem not in result:             result.append(elem)         else:             allready.append(elem)      if unique:         for elem in allready:             result = list(filter((elem).__ne__, result))      return result",
            "def dedupe_list(l):     \"\"\"Remove duplicates from a list preserving the order.      We might be tempted to use the list(set(l)) idiom, but it doesn't preserve     the order, which hinders testability and does not work for lists with     unhashable elements.     \"\"\"     result = []      for el in l:         if el not in result:             result.append(el)      return result",
            "def unique(list):     \"\"\" Returns a copy of the list without duplicates.     \"\"\"     unique = []; [unique.append(x) for x in list if x not in unique]     return unique"
        ],
        [
            "def myreplace(astr, thefind, thereplace):     \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"     alist = astr.split(thefind)     new_s = alist.split(thereplace)     return new_s",
            "def replace(s, replace):     \"\"\"Replace multiple values in a string\"\"\"     for r in replace:         s = s.replace(*r)     return s"
        ]
    ],
    [
        "python file directory self defining",
        [
            "def parent_directory(self):         \"\"\"Change working directory to parent directory\"\"\"         self.chdir(os.path.join(getcwd_or_home(), os.path.pardir))",
            "def go_to_parent_directory(self):         \"\"\"Go to parent directory\"\"\"         self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))",
            "def examples(directory):     \"\"\"     Generate example strategies to target folder     \"\"\"     source_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), \"examples\")      try:         shutil.copytree(source_dir, os.path.join(directory, \"examples\"))     except OSError as e:         if e.errno == errno.EEXIST:             six.print_(\"Folder examples is exists.\")",
            "def relative_path(path):     \"\"\"     Return the given path relative to this file.     \"\"\"     return os.path.join(os.path.dirname(__file__), path)",
            "def contained_in(filename, directory):     \"\"\"Test if a file is located within the given directory.\"\"\"     filename = os.path.normcase(os.path.abspath(filename))     directory = os.path.normcase(os.path.abspath(directory))     return os.path.commonprefix([filename, directory]) == directory"
        ],
        [
            "def relative_path(path):     \"\"\"     Return the given path relative to this file.     \"\"\"     return os.path.join(os.path.dirname(__file__), path)",
            "def contained_in(filename, directory):     \"\"\"Test if a file is located within the given directory.\"\"\"     filename = os.path.normcase(os.path.abspath(filename))     directory = os.path.normcase(os.path.abspath(directory))     return os.path.commonprefix([filename, directory]) == directory",
            "def is_readable_dir(path):   \"\"\"Returns whether a path names an existing directory we can list and read files from.\"\"\"   return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)",
            "def read(*p):     \"\"\"Build a file path from paths and return the contents.\"\"\"     with open(os.path.join(*p), 'r') as fi:         return fi.read()",
            "def get_cache_path(filename): \t\"\"\" get file path \"\"\" \tcwd = os.path.dirname(os.path.realpath(__file__)) \treturn os.path.join(cwd, filename)"
        ],
        [
            "def parent_directory(self):         \"\"\"Change working directory to parent directory\"\"\"         self.chdir(os.path.join(getcwd_or_home(), os.path.pardir))",
            "def go_to_parent_directory(self):         \"\"\"Go to parent directory\"\"\"         self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))"
        ]
    ],
    [
        "encody python to string",
        [
            "def c_str(string):     \"\"\"\"Convert a python string to C string.\"\"\"     if not isinstance(string, str):         string = string.decode('ascii')     return ctypes.c_char_p(string.encode('utf-8'))",
            "def to_unicode_repr( _letter ):     \"\"\" helpful in situations where browser/app may recognize Unicode encoding         in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"     # Python 2-3 compatible     return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"",
            "def utf8(value):     \"\"\"Converts a string argument to a byte string.      If the argument is already a byte string or None, it is returned unchanged.     Otherwise it must be a unicode string and is encoded as utf8.     \"\"\"     if isinstance(value, _UTF8_TYPES):         return value     assert isinstance(value, unicode)     return value.encode(\"utf-8\")",
            "def safe_unicode(string):     \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"     if not PY3:         uni = string.replace(u'\\u2019', \"'\")         return uni.encode('utf-8')              return string",
            "def __str__(self):         \"\"\"Return a string representation of the RedditContentObject.\"\"\"         retval = self.__unicode__()         if not six.PY3:             retval = retval.encode('utf-8')         return retval"
        ],
        [
            "def bytes_to_str(s, encoding='utf-8'):     \"\"\"Returns a str if a bytes object is given.\"\"\"     if six.PY3 and isinstance(s, bytes):         return s.decode(encoding)     return s",
            "def __str__(self):         \"\"\"Return a string representation of the RedditContentObject.\"\"\"         retval = self.__unicode__()         if not six.PY3:             retval = retval.encode('utf-8')         return retval",
            "def b2u(string):     \"\"\" bytes to unicode \"\"\"     if (isinstance(string, bytes) or         (PY2 and isinstance(string, str))):         return string.decode('utf-8')     return string",
            "def safe_unicode(string):     \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"     if not PY3:         uni = string.replace(u'\\u2019', \"'\")         return uni.encode('utf-8')              return string",
            "def to_bytes(s, encoding=\"utf-8\"):     \"\"\"Convert a string to bytes.\"\"\"     if isinstance(s, six.binary_type):         return s     if six.PY3:         return bytes(s, encoding)     return s.encode(encoding)"
        ],
        [
            "def string_repr(s):     \"\"\"Return a string as hex dump.\"\"\"     if compat.is_bytes(s):         res = \"{!r}: \".format(s)         for b in s:             if type(b) is str:  # Py2                 b = ord(b)             res += \"%02x \" % b         return res     return \"{}\".format(s)",
            "def to_unicode_repr( _letter ):     \"\"\" helpful in situations where browser/app may recognize Unicode encoding         in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"     # Python 2-3 compatible     return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\""
        ]
    ],
    [
        "function to check valid number in python",
        [
            "def is_valid(number):     \"\"\"determines whether the card number is valid.\"\"\"     n = str(number)     if not n.isdigit():         return False     return int(n[-1]) == get_check_digit(n[:-1])",
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def IntGreaterThanZero(n):     \"\"\"If *n* is an integer > 0, returns it, otherwise an error.\"\"\"     try:         n = int(n)     except:         raise ValueError(\"%s is not an integer\" % n)     if n <= 0:         raise ValueError(\"%d is not > 0\" % n)     else:         return n",
            "def is_int(value):     \"\"\"Return `True` if ``value`` is an integer.\"\"\"     if isinstance(value, bool):         return False     try:         int(value)         return True     except (ValueError, TypeError):         return False",
            "def validate_non_negative_integer(option, value):     \"\"\"Validate that 'value' is a positive integer or 0.     \"\"\"     val = validate_integer(option, value)     if val < 0:         raise ValueError(\"The value of %s must be \"                          \"a non negative integer\" % (option,))     return val"
        ],
        [
            "def is_valid(number):     \"\"\"determines whether the card number is valid.\"\"\"     n = str(number)     if not n.isdigit():         return False     return int(n[-1]) == get_check_digit(n[:-1])",
            "def is_natural(x):     \"\"\"A non-negative integer.\"\"\"     try:         is_integer = int(x) == x     except (TypeError, ValueError):         return False     return is_integer and x >= 0",
            "def is_dec(ip):     \"\"\"Return true if the IP address is in decimal notation.\"\"\"     try:         dec = int(str(ip))     except ValueError:         return False     if dec > 4294967295 or dec < 0:         return False     return True",
            "def try_convert(value):         \"\"\"Convert value to a numeric value or raise a ValueError         if that isn't possible.          \"\"\"         convertible = ForceNumeric.is_convertible(value)         if not convertible or isinstance(value, bool):             raise ValueError         if isinstance(str(value), str):             return ForceNumeric.str_to_num(value)         return float(value)",
            "def is_number(obj):     \"\"\"     Helper function to determine numbers     across Python 2.x and 3.x     \"\"\"     try:         from numbers import Number     except ImportError:         from operator import isNumberType         return isNumberType(obj)     else:         return isinstance(obj, Number)"
        ],
        [
            "def validate_non_negative_integer(option, value):     \"\"\"Validate that 'value' is a positive integer or 0.     \"\"\"     val = validate_integer(option, value)     if val < 0:         raise ValueError(\"The value of %s must be \"                          \"a non negative integer\" % (option,))     return val",
            "def validate_positive_integer(option, value):     \"\"\"Validate that 'value' is a positive integer, which does not include 0.     \"\"\"     val = validate_integer(option, value)     if val <= 0:         raise ValueError(\"The value of %s must be \"                          \"a positive integer\" % (option,))     return val"
        ]
    ],
    [
        "python terminate a pool",
        [
            "def terminate_pool(self):         \"\"\"Terminate and close the multiprocessing pool if necessary.\"\"\"          if self.pool is not None:             self.pool.terminate()             self.pool.join()             del(self.pool)             self.pool = None",
            "def timeout_thread_handler(timeout, stop_event):     \"\"\"A background thread to kill the process if it takes too long.      Args:         timeout (float): The number of seconds to wait before killing             the process.         stop_event (Event): An optional event to cleanly stop the background             thread if required during testing.     \"\"\"      stop_happened = stop_event.wait(timeout)     if stop_happened is False:         print(\"Killing program due to %f second timeout\" % timeout)      os._exit(2)",
            "def _shutdown_minions(self):         \"\"\"         send the SIGNINT signal to each worker in the pool.         \"\"\"         setproctitle('pyres_manager: Waiting on children to shutdown.')         for minion in self._workers.values():             minion.terminate()             minion.join()",
            "def blocking(func, *args, **kwargs):     \"\"\"Run a function that uses blocking IO.      The function is run in the IO thread pool.     \"\"\"     pool = get_io_pool()     fut = pool.submit(func, *args, **kwargs)     return fut.result()",
            "def Join(self):     \"\"\"Waits until all outstanding tasks are completed.\"\"\"      for _ in range(self.JOIN_TIMEOUT_DECISECONDS):       if self._queue.empty() and not self.busy_threads:         return       time.sleep(0.1)      raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)"
        ],
        [
            "def terminate_pool(self):         \"\"\"Terminate and close the multiprocessing pool if necessary.\"\"\"          if self.pool is not None:             self.pool.terminate()             self.pool.join()             del(self.pool)             self.pool = None",
            "def timeout_thread_handler(timeout, stop_event):     \"\"\"A background thread to kill the process if it takes too long.      Args:         timeout (float): The number of seconds to wait before killing             the process.         stop_event (Event): An optional event to cleanly stop the background             thread if required during testing.     \"\"\"      stop_happened = stop_event.wait(timeout)     if stop_happened is False:         print(\"Killing program due to %f second timeout\" % timeout)      os._exit(2)",
            "def _shutdown(self):     \"\"\"Terminate the sub-process.\"\"\"     if self._proc:       ret = _shutdown_proc(self._proc, 3)       logging.info(\"Shutdown with return code: %s\", ret)       self._proc = None",
            "def Join(self):     \"\"\"Waits until all outstanding tasks are completed.\"\"\"      for _ in range(self.JOIN_TIMEOUT_DECISECONDS):       if self._queue.empty() and not self.busy_threads:         return       time.sleep(0.1)      raise ValueError(\"Timeout during Join() for threadpool %s.\" % self.name)",
            "def _shutdown_minions(self):         \"\"\"         send the SIGNINT signal to each worker in the pool.         \"\"\"         setproctitle('pyres_manager: Waiting on children to shutdown.')         for minion in self._workers.values():             minion.terminate()             minion.join()"
        ],
        [
            "def blocking(func, *args, **kwargs):     \"\"\"Run a function that uses blocking IO.      The function is run in the IO thread pool.     \"\"\"     pool = get_io_pool()     fut = pool.submit(func, *args, **kwargs)     return fut.result()",
            "def _ReturnConnection(self): \t\t\"\"\" \t\tReturns a connection back to the pool \t\t \t\t@author: Nick Verbeck \t\t@since: 9/7/2008 \t\t\"\"\" \t\tif self.conn is not None: \t\t\tif self.connInfo.commitOnEnd is True or self.commitOnEnd is True: \t\t\t\tself.conn.Commit() \t\t\t\t\t \t\t\tPool().returnConnection(self.conn) \t\t\tself.conn = None"
        ]
    ],
    [
        "how to run multiple python scripts",
        [
            "def gpp(argv=None):     \"\"\"Shortcut function for running the previewing command.\"\"\"     if argv is None:         argv = sys.argv[1:]     argv.insert(0, 'preview')     return main(argv)",
            "def test(*args):     \"\"\"     Run unit tests.     \"\"\"     subprocess.call([\"py.test-2.7\"] + list(args))     subprocess.call([\"py.test-3.4\"] + list(args))",
            "def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]",
            "def load_files(files):     \"\"\"Load and execute a python file.\"\"\"      for py_file in files:         LOG.debug(\"exec %s\", py_file)         execfile(py_file, globals(), locals())",
            "def __init__(self, pidfile, daemonize=True, root=False, root_chk_argv=True, stdin=\"/dev/null\", stdout=\"/dev/null\", stderr=\"/dev/null\"): \t\t\"\"\" \t\tMake our daemon instance. \t\tpidfile: the file we're going to store the process id in. ex: /tmp/matt-daemon.pid \t\troot:    does this script require root? True if it does, False if it doesn't. Will be enforced. \t\troot_chk_argv:  does the script require '--requires-root' in sys.argv to run as root? (usage is good) \t\tstdin:   where the script gets stdin from. \"/dev/null\", \"/dev/stdin\", etc. \t\tstdout:  where the script writes stdout. \"/dev/null\", \"/dev/stdout\", etc. \t\tstderr:  where the script writes stderr. \"/dev/null\", \"/dev/stderr\", etc. \t\t\"\"\" \t\t# Enforce root usage or non-usage. \t\tRootCheck.check(root, check_argv=root_chk_argv) \t\tself.pidfile = pidfile \t\tself.should_daemonize = daemonize \t\tself.stdin = stdin \t\tself.stdout = stdout \t\tself.stderr = stderr"
        ],
        [
            "def gpp(argv=None):     \"\"\"Shortcut function for running the previewing command.\"\"\"     if argv is None:         argv = sys.argv[1:]     argv.insert(0, 'preview')     return main(argv)",
            "def callprint(self, cmd, shell=None, lock_file=None, nofail=False, container=None):         \"\"\"         Prints the command, and then executes it, then prints the memory use and         return code of the command.          Uses python's subprocess.Popen() to execute the given command. The shell argument is simply         passed along to Popen(). You should use shell=False (default) where possible, because this enables memory         profiling. You should use shell=True if you require shell functions like redirects (>) or stars (*), but this         will prevent the script from monitoring memory use. The pipes (|) will be used to split the command into         subprocesses run within python, so the memory profiling is possible.          cmd can also be a series (a dict object) of multiple commands, which will be run in succession.          :param str | Iterable[str] cmd: Bash command(s) to be run.         :param str lock_file: a lock file name         :param bool nofail: Should the pipeline bail on a nonzero return from a process? Default: False             Nofail can be used to implement non-essential parts of the pipeline; if these processes fail,             they will not cause the pipeline to bail out.         :param bool shell: if the command should be run it its own shell, default: None (will try             to determine based on the command)         :param container: Named Docker container in which to execute.         :param container: str         \"\"\"         # The Popen shell argument works like this:         # if shell=False, then we format the command (with split()) to be a list of command and its arguments.         # Split the command to use shell=False;         # leave it together to use shell=True;          def get_mem_child_sum(proc):             try:                 # get children processes                 children = proc.children(recursive=True)                 # get RSS memory of each child proc and sum all                 mem_sum = sum([x.memory_info().rss for x in children])                 # return in gigs                 return mem_sum/1e9             except (psutil.NoSuchProcess, psutil.ZombieProcess) as e:                 print(e)                 print(\"Warning: couldn't add memory use for process: {}\".format(proc.pid))                 return 0           def display_memory(memval):             return None if memval < 0 else \"{}GB\".format(round(memval, 3))          def make_dict(command):             a, s = (command, True) if check_shell(command, shell) else (shlex.split(command), False)             return dict(args=a, stdout=subprocess.PIPE, shell=s)          if container:             cmd = \"docker exec \" + container + \" \" + cmd          param_list = [make_dict(c) for c in split_by_pipes(cmd)] \\             if check_shell_pipes(cmd) else [dict(args=cmd, stdout=None, shell=True)]          proc_name = get_proc_name(cmd)          # stop_times = []         processes = []         running_processes = []         start_time = time.time()         for i in range(len(param_list)):             running_processes.append(i)             if i == 0:                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))             else:                 param_list[i][\"stdin\"] = processes[i - 1].stdout                 processes.append(psutil.Popen(preexec_fn=os.setpgrp, **param_list[i]))              self.procs[processes[-1].pid] = {                 \"proc_name\": proc_name,                 \"subproc_name\" : get_proc_name(param_list[i][\"args\"]),                 \"start_time\": start_time,                 \"container\": container,                 \"p\": processes[-1]             }          self._report_command(cmd, [x.pid for x in processes])             # Capture the subprocess output in <pre> tags to make it format nicely             # if the markdown log file is displayed as HTML.         print(\"<pre>\")          local_maxmems = [-1] * len(running_processes)         returncodes = [None] * len(running_processes)          if not self.wait:             print(\"</pre>\")             ids = [x.pid for x in processes]             print (\"Not waiting for subprocess(es): \" + str(ids))             return [0, -1]          def proc_wrapup(i):             \"\"\"             :param i: internal ID number of the subprocess             \"\"\"             returncode = processes[i].returncode             current_pid = processes[i].pid              info = \"Process {pid} returned {ret}; memory: {mem}. \".format(                 pid=current_pid,                  ret=processes[i].returncode,                 mem=display_memory(local_maxmems[i]))                          # report process profile             self._report_profile(self.procs[current_pid][\"proc_name\"], lock_file, time.time() - self.procs[current_pid][\"start_time\"], local_maxmems[i])              # Remove this as a running subprocess             del self.procs[current_pid]             running_processes.remove(i)              returncodes[i] = returncode             return info           sleeptime = .0001         info = \"\"         while running_processes:             for i in running_processes:                 local_maxmems[i] = max(local_maxmems[i], (get_mem_child_sum(processes[i])))                 self.peak_memory = max(self.peak_memory, local_maxmems[i])                 if not self._attend_process(processes[i], sleeptime):                     info += proc_wrapup(i)              # the sleeptime is extremely short at the beginning and gets longer exponentially              # (+ constant to prevent copious checks at the very beginning)             # = more precise mem tracing for short processes             sleeptime = min((sleeptime + 0.25) * 3 , 60/len(processes))          # All jobs are done, print a final closing and job info         stop_time = time.time()         info += \" Elapsed: \" + str(datetime.timedelta(seconds=self.time_elapsed(start_time))) + \".\"         info += \" Peak memory: {pipe}.\".format(pipe=display_memory(self.peak_memory))          print(\"</pre>\")         print(info)          for rc in returncodes:             if rc != 0:                 msg = \"Subprocess returned nonzero result. Check above output for details\"                 self._triage_error(SubprocessError(msg), nofail)            return [returncodes, local_maxmems]",
            "def _handle_shell(self,cfg_file,*args,**options):         \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"         args = (\"--interactive\",) + args         return supervisorctl.main((\"-c\",cfg_file) + args)",
            "def server(port):     \"\"\"Start the Django dev server.\"\"\"     args = ['python', 'manage.py', 'runserver']     if port:         args.append(port)     run.main(args)",
            "def __init__(self, pidfile, daemonize=True, root=False, root_chk_argv=True, stdin=\"/dev/null\", stdout=\"/dev/null\", stderr=\"/dev/null\"): \t\t\"\"\" \t\tMake our daemon instance. \t\tpidfile: the file we're going to store the process id in. ex: /tmp/matt-daemon.pid \t\troot:    does this script require root? True if it does, False if it doesn't. Will be enforced. \t\troot_chk_argv:  does the script require '--requires-root' in sys.argv to run as root? (usage is good) \t\tstdin:   where the script gets stdin from. \"/dev/null\", \"/dev/stdin\", etc. \t\tstdout:  where the script writes stdout. \"/dev/null\", \"/dev/stdout\", etc. \t\tstderr:  where the script writes stderr. \"/dev/null\", \"/dev/stderr\", etc. \t\t\"\"\" \t\t# Enforce root usage or non-usage. \t\tRootCheck.check(root, check_argv=root_chk_argv) \t\tself.pidfile = pidfile \t\tself.should_daemonize = daemonize \t\tself.stdin = stdin \t\tself.stdout = stdout \t\tself.stderr = stderr"
        ],
        [
            "def load_files(files):     \"\"\"Load and execute a python file.\"\"\"      for py_file in files:         LOG.debug(\"exec %s\", py_file)         execfile(py_file, globals(), locals())",
            "def stub_main():     \"\"\"setuptools blah: it still can't run a module as a script entry_point\"\"\"     from google.apputils import run_script_module     import butcher.main     run_script_module.RunScriptModule(butcher.main)"
        ]
    ],
    [
        "python switch test if variable exists",
        [
            "def _not_none(items):     \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"     if not isinstance(items, (tuple, list)):         items = (items,)     return all(item is not _none for item in items)",
            "def has_attribute(module_name, attribute_name):     \"\"\"Is this attribute present?\"\"\"     init_file = '%s/__init__.py' % module_name     return any(         [attribute_name in init_line for init_line in open(init_file).readlines()]     )",
            "def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]",
            "def boolean(value):     \"\"\"     Configuration-friendly boolean type converter.      Supports both boolean-valued and string-valued inputs (e.g. from env vars).      \"\"\"     if isinstance(value, bool):         return value      if value == \"\":         return False      return strtobool(value)",
            "def _has(self, key, exact=0):          \"\"\"Returns false if key is not found or is ambiguous\"\"\"          if not exact:             try:                 key = self.getfullkey(key)                 return 1             except KeyError:                 return 0         else:             return key in self.data"
        ],
        [
            "def chk_enum_arg(s):     \"\"\"Checks if the string `s` is a valid enum string.      Return True or False.\"\"\"      if len(s) == 0 or s[0].isspace() or s[-1].isspace():         return False     else:         return True",
            "def is_identifier(string):     \"\"\"Check if string could be a valid python identifier      :param string: string to be tested     :returns: True if string can be a python identifier, False otherwise     :rtype: bool     \"\"\"     matched = PYTHON_IDENTIFIER_RE.match(string)     return bool(matched) and not keyword.iskeyword(string)",
            "def boolean(value):     \"\"\"     Configuration-friendly boolean type converter.      Supports both boolean-valued and string-valued inputs (e.g. from env vars).      \"\"\"     if isinstance(value, bool):         return value      if value == \"\":         return False      return strtobool(value)",
            "def hard_equals(a, b):     \"\"\"Implements the '===' operator.\"\"\"     if type(a) != type(b):         return False     return a == b",
            "def strToBool(val):     \"\"\"     Helper function to turn a string representation of \"true\" into     boolean True.     \"\"\"     if isinstance(val, str):         val = val.lower()      return val in ['true', 'on', 'yes', True]"
        ],
        [
            "def has_attribute(module_name, attribute_name):     \"\"\"Is this attribute present?\"\"\"     init_file = '%s/__init__.py' % module_name     return any(         [attribute_name in init_line for init_line in open(init_file).readlines()]     )",
            "def column_exists(cr, table, column):     \"\"\" Check whether a certain column exists \"\"\"     cr.execute(         'SELECT count(attname) FROM pg_attribute '         'WHERE attrelid = '         '( SELECT oid FROM pg_class WHERE relname = %s ) '         'AND attname = %s',         (table, column))     return cr.fetchone()[0] == 1"
        ]
    ],
    [
        "python folding multiple strings",
        [
            "def add_colons(s):     \"\"\"Add colons after every second digit.      This function is used in functions to prettify serials.      >>> add_colons('teststring')     'te:st:st:ri:ng'     \"\"\"     return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])",
            "def concat_padded(base, *args):     \"\"\"     Concatenate string and zero-padded 4 digit number     \"\"\"     ret = base     for n in args:         if is_string(n):             ret = \"%s_%s\" % (ret, n)         else:             ret = \"%s_%04i\"  % (ret, n + 1)     return ret",
            "def commajoin_as_strings(iterable):     \"\"\" Join the given iterable with ',' \"\"\"     return _(u',').join((six.text_type(i) for i in iterable))",
            "def reduce_multiline(string):     \"\"\"     reduces a multiline string to a single line of text.       args:         string: the text to reduce     \"\"\"     string = str(string)     return \" \".join([item.strip()                      for item in string.split(\"\\n\")                      if item.strip()])",
            "def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]"
        ],
        [
            "def upcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to upper case.\"\"\"     return [ tt.upper() for tt in map(_ustr,t) ]",
            "def add_colons(s):     \"\"\"Add colons after every second digit.      This function is used in functions to prettify serials.      >>> add_colons('teststring')     'te:st:st:ri:ng'     \"\"\"     return ':'.join([s[i:i + 2] for i in range(0, len(s), 2)])",
            "def downcaseTokens(s,l,t):     \"\"\"Helper parse action to convert tokens to lower case.\"\"\"     return [ tt.lower() for tt in map(_ustr,t) ]",
            "def list2string (inlist,delimit=' '):     \"\"\" Converts a 1D list to a single long string for file output, using the string.join function.  Usage:   list2string (inlist,delimit=' ') Returns: the string created from inlist \"\"\"     stringlist = [makestr(_) for _ in inlist]     return string.join(stringlist,delimit)",
            "def concat_padded(base, *args):     \"\"\"     Concatenate string and zero-padded 4 digit number     \"\"\"     ret = base     for n in args:         if is_string(n):             ret = \"%s_%s\" % (ret, n)         else:             ret = \"%s_%04i\"  % (ret, n + 1)     return ret"
        ],
        [
            "def split(s):   \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"   l = [_split(x) for x in _SPLIT_RE.split(s)]   return [item for sublist in l for item in sublist]",
            "def clean_strings(iterable):     \"\"\"     Take a list of strings and clear whitespace      on each one. If a value in the list is not a      string pass it through untouched.      Args:         iterable: mixed list      Returns:          mixed list     \"\"\"     retval = []     for val in iterable:         try:             retval.append(val.strip())         except(AttributeError):             retval.append(val)     return retval"
        ]
    ],
    [
        "using dictionaries to prove password username combinations in python",
        [
            "def check_auth(username, pwd):     \"\"\"This function is called to check if a username /     password combination is valid.     \"\"\"     cfg = get_current_config()     return username == cfg[\"dashboard_httpauth\"].split(         \":\")[0] and pwd == cfg[\"dashboard_httpauth\"].split(\":\")[1]",
            "def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]",
            "def __contains__(self, key):         \"\"\" Tests if a key is contained in the store.              May test againsts self.defaults              :param str value: Value         \"\"\"         if self._haveKey(key) or key in self.defaults:             return True         else:             return False",
            "def __contains__(self, key):         \"\"\"         Invoked when determining whether a specific key is in the dictionary         using `key in d`.          The key is looked up case-insensitively.         \"\"\"         k = self._real_key(key)         return k in self._data",
            "def authenticate_user(scope, user=[None], password=[None]):     \"\"\"     Like authenticate(), but logs in using the given user and password.     If a user and password are not given, the function uses the same     user and password that were used at the last login attempt; it is     an error if no such attempt was made before.      :type  user: string     :param user: A username.     :type  password: string     :param password: A password.     \"\"\"     conn = scope.get('__connection__')     user = user[0]     if user is None:         conn.app_authenticate()     else:         account = Account(user, password[0])         conn.app_authenticate(account)     return True"
        ],
        [
            "def __contains__(self, item):         \"\"\"(dpid, key) in <ConfSwitchSet instance>\"\"\"         (dpid, key) = item         return dpid in self.confs and key in self.confs[dpid]",
            "def intersect(d1, d2):     \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"     return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])",
            "def is_valid_row(cls, row):         \"\"\"Indicates whether or not the given row contains valid data.\"\"\"         for k in row.keys():             if row[k] is None:                 return False         return True",
            "def get_case_insensitive_dict_key(d: Dict, k: str) -> Optional[str]:     \"\"\"     Within the dictionary ``d``, find a key that matches (in case-insensitive     fashion) the key ``k``, and return it (or ``None`` if there isn't one).     \"\"\"     for key in d.keys():         if k.lower() == key.lower():             return key     return None",
            "def __eq__(self, other):         \"\"\"         Returns +true+ if the other object is a MIME::Type and the content         types match.         \"\"\"         return isinstance(other, self.__class__) and cmp(self, other) == 0"
        ],
        [
            "def check_auth(username, pwd):     \"\"\"This function is called to check if a username /     password combination is valid.     \"\"\"     cfg = get_current_config()     return username == cfg[\"dashboard_httpauth\"].split(         \":\")[0] and pwd == cfg[\"dashboard_httpauth\"].split(\":\")[1]",
            "def check_auth(email, password):     \"\"\"Check if a username/password combination is valid.     \"\"\"     try:         user = User.get(User.email == email)     except User.DoesNotExist:         return False     return password == user.password"
        ]
    ]
]